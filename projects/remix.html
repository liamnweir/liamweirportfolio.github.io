<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Remix Assistant (MIDI) | Liam Weir</title>

  <!-- Tone.js playback -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
  <!-- MIDI parse + write (browser) -->
  <script src="https://unpkg.com/@tonejs/midi"></script>

  <style>
    :root{
      /* Purple/black vibe */
      --bg0:#070712;
      --bg1:#0b0820;
      --bg2:#120a2c;

      --panel: rgba(255,255,255,.055);
      --panel2: rgba(255,255,255,.038);
      --border: rgba(255,255,255,.12);

      --text:#eef0ff;
      --muted:rgba(238,240,255,.78);
      --muted2:rgba(238,240,255,.62);

      --accentA: rgba(200,120,255,.22);
      --accentB: rgba(120,140,255,.20);
      --accentC: rgba(120,255,200,.14);
      --accentBorder: rgba(200,120,255,.48);

      --ok: rgba(120,255,190,.14);
      --okBorder: rgba(120,255,190,.28);
      --warnBg: rgba(255,170,120,.10);
      --warnBorder: rgba(255,170,120,.32);

      --shadow: 0 30px 70px rgba(0,0,0,.52);
      --r: 20px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    *{box-sizing:border-box}
    html{scroll-behavior:smooth}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--text);
      background:
        radial-gradient(900px 520px at 18% -10%, rgba(200,120,255,.22), transparent 58%),
        radial-gradient(860px 520px at 92% 0%, rgba(120,140,255,.18), transparent 62%),
        radial-gradient(980px 640px at 50% 110%, rgba(120,255,200,.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 50%, var(--bg2));
      overflow-x:hidden;
    }
    a{color:inherit}

    /* Topbar */
    .topbar{
      position:sticky; top:0; z-index:10;
      background: rgba(10, 8, 26, .78);
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(14px);
      padding: 14px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .navL{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .brand{
      font-weight: 950;
      letter-spacing:.2px;
      display:flex; align-items:center; gap:10px;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: linear-gradient(135deg, rgba(200,120,255,.95), rgba(120,140,255,.95));
      box-shadow: 0 0 0 5px rgba(200,120,255,.18);
    }
    .navBtn{
      text-decoration:none;
      font-weight: 900;
      padding: 9px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(238,240,255,.92);
      transition: transform .12s ease, filter .12s ease;
    }
    .navBtn.primary{
      background: linear-gradient(135deg, rgba(200,120,255,.22), rgba(120,140,255,.18));
      border: 1px solid rgba(200,120,255,.42);
    }
    .navBtn:hover{filter:brightness(1.12); transform: translateY(-1px)}
    .tiny{font-size:.88rem; color:var(--muted2); font-weight:800}

    .wrap{max-width:1180px; margin:0 auto; padding: 18px 16px 70px}

    /* Header */
    .hero{
      margin-top: 10px;
      padding: 16px;
      border-radius: var(--r);
      border: 1px solid var(--border);
      background:
        radial-gradient(900px 340px at 20% 0%, rgba(200,120,255,.16), transparent 60%),
        radial-gradient(900px 340px at 90% 10%, rgba(120,140,255,.14), transparent 60%),
        rgba(255,255,255,.035);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .hero::before{
      content:"";
      position:absolute;
      inset:-40%;
      background:
        radial-gradient(circle at 20% 20%, rgba(200,120,255,.22), transparent 40%),
        radial-gradient(circle at 70% 35%, rgba(120,140,255,.20), transparent 45%),
        radial-gradient(circle at 45% 80%, rgba(120,255,200,.12), transparent 45%);
      filter: blur(12px);
      transform: rotate(10deg);
      opacity:.7;
      pointer-events:none;
    }
    .hero > *{position:relative; z-index:1}

    h1{margin: 4px 0 8px; font-size: 2.35rem; letter-spacing:-0.6px}
    p{margin: 6px 0; line-height: 1.6; color: var(--muted)}

    .pills{display:flex; flex-wrap:wrap; gap:8px; margin-top:10px}
    .pill{
      padding: 7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      color: rgba(238,240,255,.80);
      font-size: .86rem;
      white-space: nowrap;
      font-weight: 850;
    }

    /* Layout grid */
    .grid{display:grid; grid-template-columns: 1.15fr .85fr; gap: 16px; margin-top: 16px}
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }

    /* Cards */
    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: 16px;
      overflow:hidden;
    }
    .card.soft{ background: var(--panel2); }
    .cardHeader{
      display:flex; align-items:flex-start; justify-content:space-between; gap: 12px;
      margin-bottom: 10px;
    }
    .cardHeader h2{margin:0; font-size: 1.25rem; letter-spacing:-0.2px}

    .divider{border:0; border-top:1px solid rgba(255,255,255,.10); margin: 12px 0}
    .row{display:flex; flex-wrap:wrap; gap: 10px; align-items:flex-end}
    .field{min-width: 220px; flex:1}
    .field.sm{min-width: 170px; flex: .75}
    .field.xs{min-width: 140px; flex: .6}
    .label{font-size:.9rem; color: var(--muted); margin: 0 0 6px; font-weight: 850}

    select,input[type="text"],input[type="number"],input[type="file"],input[type="range"],textarea{
      width:100%;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 14px;
      color: rgba(238,240,255,.92);
      padding: 10px 12px;
      outline:none;
      transition: filter .12s ease, border-color .12s ease;
    }
    select:focus,input:focus,textarea:focus{
      border-color: rgba(200,120,255,.45);
      filter: brightness(1.06);
    }
    textarea{min-height: 84px; resize: vertical}

    .btn{
      appearance:none;
      border: 1px solid rgba(200,120,255,.48);
      background: linear-gradient(135deg, rgba(200,120,255,.22), rgba(120,140,255,.18));
      color: rgba(238,240,255,.96);
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 950;
      letter-spacing: .2px;
      transition: transform .12s ease, filter .12s ease;
    }
    .btn:hover{filter:brightness(1.12); transform: translateY(-1px)}
    .btn:disabled{opacity:.45; cursor:not-allowed; transform:none}
    .btn.secondary{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.16);
      font-weight: 900;
    }
    .btn.ghost{
      background: transparent;
      border-color: rgba(255,255,255,.16);
      font-weight: 900;
    }

    .warn{
      display:none;
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--warnBorder);
      background: var(--warnBg);
      color: #ffe9da;
      white-space: pre-wrap;
      font-weight: 850;
    }
    .ok{
      display:none;
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--okBorder);
      background: var(--ok);
      color: rgba(220,255,235,.96);
      white-space: pre-wrap;
      font-weight: 850;
    }

    pre{
      margin: 10px 0 0;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
      color: rgba(238,240,255,.90);
      overflow:auto;
      min-height: 140px;
      font-family: var(--mono);
      font-size: .9rem;
      line-height: 1.45;
    }

    .toggle{
      display:inline-flex; align-items:center; gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      cursor:pointer;
      user-select:none;
      font-size: .9rem;
      color: rgba(238,240,255,.88);
      font-weight: 900;
      transition: transform .12s ease, filter .12s ease;
    }
    .toggle:hover{transform: translateY(-1px); filter: brightness(1.08)}
    .toggle input{transform: translateY(1px)}
    .toggles{display:flex; gap: 10px; flex-wrap:wrap}

    .kv{display:flex; justify-content:space-between; gap: 10px; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,.10)}
    .kv:last-child{border-bottom:none}
    .k{color: var(--muted)}
    .v{font-weight: 950}

    .tabs{display:flex; gap: 8px; flex-wrap:wrap}
    .tab{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      cursor:pointer;
      font-weight: 900;
      color: rgba(238,240,255,.86);
      transition: transform .12s ease, filter .12s ease;
    }
    .tab:hover{transform: translateY(-1px); filter: brightness(1.08)}
    .tab.active{
      background: linear-gradient(135deg, rgba(200,120,255,.22), rgba(120,140,255,.18));
      border-color: rgba(200,120,255,.42);
      color: rgba(238,240,255,.96);
    }

    .canvasWrap{
      margin-top: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.28);
      overflow:hidden;
    }
    canvas{display:block; width:100%; height:auto}

    .stars{display:flex; gap: 6px; flex-wrap:wrap; align-items:center}
    .star{
      width: 34px; height: 34px; border-radius: 12px;
      display:grid; place-items:center;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      cursor:pointer; user-select:none;
      font-size: 18px;
      transition: transform .12s ease, filter .12s ease;
    }
    .star:hover{transform: translateY(-1px); filter: brightness(1.1)}
    .star.on{background: linear-gradient(135deg, rgba(200,120,255,.22), rgba(120,140,255,.18)); border-color: rgba(200,120,255,.42)}

    table{width:100%; border-collapse: collapse; margin-top: 10px; font-size: .92rem}
    th,td{padding: 10px; border-bottom: 1px solid rgba(255,255,255,.10); vertical-align: top}
    th{text-align:left; color: rgba(238,240,255,.82); font-weight: 950}
    code{font-family: var(--mono); font-size: .92em}

    details summary{cursor:pointer; font-weight: 950; color: rgba(238,240,255,.90)}
    .list{margin: 8px 0 0; padding-left: 18px; color: var(--muted); line-height: 1.65}
    .rightColSticky{position:sticky; top: 74px}
    @media (max-width: 980px){ .rightColSticky{position:static} }

    /* Tiny hint card styling */
    .hint{
      border: 1px solid rgba(200,120,255,.24);
      background: rgba(200,120,255,.06);
      border-radius: 14px;
      padding: 10px 12px;
      color: rgba(238,240,255,.86);
      font-weight: 850;
      line-height: 1.55;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="navL">
      <div class="brand"><span class="dot"></span>Remix Assistant</div>
      <a class="navBtn" href="https://liamnweir.github.io/liamweirportfolio.github.io/">← Back</a>
      <a class="navBtn primary" href="#" id="jumpDemo">Demo</a>
      <a class="navBtn" href="#" id="jumpStudy">A/B Study</a>
      <a class="navBtn" href="#" id="jumpEvidence">Evidence</a>
    </div>
    <div class="tiny">Upload MIDI → remix → compare → download</div>
  </div>

  <div class="wrap">
    <div class="hero">
      <h1>Remix Assistant (MIDI)</h1>
      <p>
        Upload a MIDI idea and generate a remix with better harmony, bass motion, and musical phrasing.
        Then A/B compare and export the remix as a new MIDI file.
      </p>

      <div class="pills">
        <span class="pill">Reharm + voicings</span>
        <span class="pill">Broken chords</span>
        <span class="pill">Bass movement</span>
        <span class="pill">Counter line</span>
        <span class="pill">A/B listening</span>
        <span class="pill">MIDI export</span>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT -->
      <div>
        <!-- DEMO -->
        <section class="card" id="demo">
          <div class="cardHeader">
            <h2>Demo</h2>
            <div class="tabs" role="tablist" aria-label="Demo tabs">
              <button class="tab active" id="tabUpload" type="button">Upload</button>
              <button class="tab" id="tabExamples" type="button">Examples</button>
              <button class="tab" id="tabSettings" type="button">Settings</button>
            </div>
          </div>

          <!-- Upload -->
          <div id="panelUpload">
            <div class="row">
              <div class="field">
                <div class="label">Upload MIDI (.mid)</div>
                <input id="midiFile" type="file" accept=".mid,.midi,audio/midi" />
                <div class="tiny" style="margin-top:6px">
                  Tip: melody/piano MIDIs work great. Multi-track is fine too.
                </div>
              </div>
            </div>
          </div>

          <!-- Examples -->
          <div id="panelExamples" style="display:none">
            <div class="row">
              <div class="field">
                <div class="label">Load a built-in example</div>
                <select id="examplePick">
                  <option value="pop" selected>Example 1: Pop-ish melody (C major)</option>
                  <option value="minor">Example 2: Minor arpeggio hook (A minor)</option>
                  <option value="riff">Example 3: Riff + rests (D mixolydian-ish)</option>
                </select>
              </div>
              <div class="field xs">
                <div class="label">Tempo</div>
                <input id="exTempo" type="number" min="40" max="220" value="110" />
              </div>
              <div class="field xs">
                <div class="label">Bars</div>
                <input id="exBars" type="number" min="2" max="16" value="8" />
              </div>
              <div class="field xs">
                <div class="label">Load</div>
                <button class="btn" id="loadExampleBtn" type="button">Load Example</button>
              </div>
            </div>
          </div>

          <!-- Settings -->
          <div id="panelSettings" style="display:none">
            <div class="row">
              <div class="field sm">
                <div class="label">Style preset</div>
                <select id="style">
                  <option value="lofi" selected>Lofi (swing + warm harmony)</option>
                  <option value="edm">EDM (tight groove + punchy bass)</option>
                  <option value="baroque">Baroque-ish (broken chords + walking bass)</option>
                </select>
              </div>

              <div class="field xs">
                <div class="label">Time signature</div>
                <select id="barsize">
                  <option value="4" selected>4/4</option>
                  <option value="3">3/4</option>
                </select>
              </div>

              <div class="field sm">
                <div class="label">Remix strength</div>
                <input id="strength" type="range" min="0" max="1" step="0.01" value="0.75" />
                <div class="tiny">Value: <span id="strengthVal">0.75</span> (higher = denser bass/counter/texture)</div>
              </div>

              <div class="field sm">
                <div class="label">Swing (lofi)</div>
                <input id="swing" type="range" min="0" max="0.6" step="0.01" value="0.22" />
                <div class="tiny">Value: <span id="swingVal">0.22</span></div>
              </div>

              <div class="field sm">
                <div class="label">Humanize (seconds)</div>
                <input id="humanize" type="range" min="0" max="0.03" step="0.001" value="0.008" />
                <div class="tiny">Value: <span id="humVal">0.008</span></div>
              </div>

              <div class="field xs">
                <div class="label">Seed (optional)</div>
                <input id="seed" type="number" placeholder="e.g., 42" />
                <div class="tiny">Same seed + settings → repeatable output.</div>
              </div>

              <div class="field sm">
                <div class="label">Key</div>
                <select id="keyOverride">
                  <option value="auto" selected>Auto detect</option>
                  <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
                  <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
                  <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
                </select>
              </div>

              <div class="field sm">
                <div class="label">Scale / Mode</div>
                <select id="modeOverride">
                  <option value="major" selected>Major (Ionian)</option>
                  <option value="minor">Minor (Aeolian)</option>
                  <option value="dorian">Dorian</option>
                  <option value="phrygian">Phrygian</option>
                  <option value="lydian">Lydian</option>
                  <option value="mixolydian">Mixolydian</option>
                </select>
                <div class="tiny">Modes change the vibe while keeping a “key center”.</div>
              </div>

              <div class="field sm">
                <div class="label">Pitch clean-up</div>
                <div class="toggles">
                  <label class="toggle"><input id="lockToScale" type="checkbox" checked /> Gently lock notes to scale</label>
                  <label class="toggle"><input id="preferPentatonic" type="checkbox" /> Prefer pentatonic tones (melody/counter)</label>
                </div>
              </div>
            </div>

            <div class="divider"></div>

            <div class="label">Remix components</div>
            <div class="toggles">
              <label class="toggle"><input id="doChords" type="checkbox" checked /> Harmony</label>
              <label class="toggle"><input id="doBass" type="checkbox" checked /> Bassline</label>
              <label class="toggle"><input id="doCounter" type="checkbox" checked /> Counter-melody</label>
              <label class="toggle"><input id="doRhythm" type="checkbox" checked /> Rhythm variation</label>
            </div>

            <div class="divider"></div>

            <div class="hint">
              Music theory tweaks built-in: the remix tends to <strong>start/end on the tonic</strong>,
              uses <strong>broken chords</strong>, applies <strong>smooth inversions</strong>,
              and adds <strong>bass motion</strong> that supports the harmony.
            </div>
          </div>

          <div class="divider"></div>

          <div class="row">
            <button class="btn" id="remixBtn" disabled type="button">Create Remix</button>
            <button class="btn secondary" id="playOrigBtn" disabled type="button">Play Original</button>
            <button class="btn secondary" id="playRemixBtn" disabled type="button">Play Remix</button>
            <button class="btn secondary" id="stopBtn" disabled type="button">Stop</button>
            <button class="btn" id="downloadBtn" disabled type="button">Download Remix MIDI</button>
          </div>

          <div id="warn" class="warn"></div>
          <div id="ok" class="ok"></div>

          <div class="label" style="margin-top:12px">Log</div>
          <pre id="log">(upload a MIDI file or load an example)</pre>

          <div class="tiny" style="margin-top:10px">
            Shortcuts: <span style="font-family:var(--mono)">R</span> remix •
            <span style="font-family:var(--mono)">O</span> play original •
            <span style="font-family:var(--mono)">P</span> play remix •
            <span style="font-family:var(--mono)">Space</span> stop
          </div>
        </section>

        <!-- A/B LISTENING STUDY -->
        <section class="card soft" id="study" style="margin-top:16px">
          <div class="cardHeader">
            <h2>A/B Listening Study</h2>
            <div class="tiny">Blind compare Original vs Remix (randomized A/B)</div>
          </div>

          <p class="tiny">
            Click “Start A/B Test” to randomize which version is A vs B. Play both, then submit ratings.
            Results are stored locally and can be exported as CSV.
          </p>

          <div class="row" style="margin-top:10px">
            <button class="btn" id="abStartBtn" disabled type="button">Start A/B Test</button>
            <button class="btn secondary" id="playAB_A" disabled type="button">Play A</button>
            <button class="btn secondary" id="playAB_B" disabled type="button">Play B</button>
            <button class="btn secondary" id="abStopBtn" disabled type="button">Stop</button>
            <button class="btn ghost" id="abRevealBtn" disabled type="button">Reveal Mapping</button>
          </div>

          <div class="tiny" style="margin-top:8px">
            Test ID: <span id="abId" style="font-family:var(--mono)">—</span> •
            Mapping: <span id="abMap" style="font-family:var(--mono)">Hidden</span>
          </div>

          <div class="divider"></div>

          <div class="row">
            <div class="field sm">
              <div class="label">Preference</div>
              <select id="pref">
                <option value="" selected>Choose…</option>
                <option value="A">Prefer A</option>
                <option value="B">Prefer B</option>
                <option value="tie">Tie / no preference</option>
              </select>
              <div class="tiny">Which one would you keep / use?</div>
            </div>

            <div class="field sm">
              <div class="label">Overall quality (1–5)</div>
              <div class="stars" id="starsQuality" aria-label="Quality stars"></div>
              <div class="tiny" id="qHint">Click stars to rate.</div>
            </div>

            <div class="field sm">
              <div class="label">Creativity (1–5)</div>
              <div class="stars" id="starsCreativity" aria-label="Creativity stars"></div>
              <div class="tiny" id="cHint">Click stars to rate.</div>
            </div>

            <div class="field sm">
              <div class="label">Coherence (1–5)</div>
              <div class="stars" id="starsCoherence" aria-label="Coherence stars"></div>
              <div class="tiny" id="coHint">Click stars to rate.</div>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div class="field">
              <div class="label">Comment (optional)</div>
              <textarea id="abComment" placeholder="e.g., 'Nice bass motion, but bar 3 chords feel too dense'"></textarea>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <button class="btn" id="saveABBtn" disabled type="button">Save A/B Result</button>
            <button class="btn secondary" id="exportABBtn" type="button">Export Results CSV</button>
            <button class="btn secondary" id="clearABBtn" type="button">Clear Local Results</button>
          </div>

          <div class="divider"></div>

          <div class="label">Recent results (this device)</div>
          <table>
            <thead>
              <tr>
                <th style="width:180px">When</th>
                <th style="width:120px">Winner</th>
                <th>Condition</th>
              </tr>
            </thead>
            <tbody id="abTable">
              <tr><td colspan="3" class="tiny">No study results yet.</td></tr>
            </tbody>
          </table>
        </section>

        <!-- EVIDENCE -->
        <section class="card" id="evidence" style="margin-top:16px">
          <div class="cardHeader">
            <h2>Evidence</h2>
            <div class="tiny">Plots update from your saved A/B results</div>
          </div>

          <div class="row">
            <div class="field">
              <div class="canvasWrap"><canvas id="plotPref"></canvas></div>
              <div class="tiny" style="margin-top:6px">Preference outcomes (who “wins” in A/B)</div>
            </div>
            <div class="field">
              <div class="canvasWrap"><canvas id="plotAvg"></canvas></div>
              <div class="tiny" style="margin-top:6px">Average ratings by winner (quality/creativity/coherence)</div>
            </div>
          </div>

          <div class="row" style="margin-top:12px">
            <div class="field">
              <div class="canvasWrap"><canvas id="plotStyle"></canvas></div>
              <div class="tiny" style="margin-top:6px">Preference by style preset (remix win-rate)</div>
            </div>
            <div class="field">
              <div class="canvasWrap"><canvas id="plotStrength"></canvas></div>
              <div class="tiny" style="margin-top:6px">Preference by strength bucket</div>
            </div>
          </div>

          <details style="margin-top:10px">
            <summary>Quick summary</summary>
            <p class="tiny" style="margin-top:8px">
              Across <span id="nTests">0</span> A/B tests on this device, listeners preferred the Remix
              <strong><span id="remixWinPct">0%</span></strong> of the time (ties excluded).
              Remix wins were strongest in <strong><span id="bestStyle">—</span></strong> and at
              <strong><span id="bestStrength">—</span></strong> strength.
            </p>
          </details>
        </section>
      </div>

      <!-- RIGHT -->
      <div class="rightColSticky">
        <section class="card">
          <div class="cardHeader">
            <h2>Stats</h2>
            <div class="tiny">What the tool detected / used</div>
          </div>

          <div class="kv"><span class="k">Detected file</span><span class="v" id="statFile">—</span></div>
          <div class="kv"><span class="k">Tempo</span><span class="v" id="statBpm">—</span></div>
          <div class="kv"><span class="k">Key / mode</span><span class="v" id="statKey">—</span></div>
          <div class="kv"><span class="k">Melody track</span><span class="v" id="statTrack">—</span></div>
          <div class="kv"><span class="k">Duration</span><span class="v" id="statDur">—</span></div>

          <div class="divider"></div>

          <div class="hint">
            If your input MIDI is “weird” harmonically, try:
            <ul class="list" style="margin-top:6px">
              <li>Set Key manually (Settings).</li>
              <li>Try a different Mode (Mixolydian/Dorian can sound great).</li>
              <li>Turn on “Prefer pentatonic tones”.</li>
              <li>Lower strength if it feels too busy.</li>
            </ul>
          </div>
        </section>
      </div>
    </div>
  </div>

  <script>
    // ------------------------------------------------------------
    // Utilities + seeded RNG
    // ------------------------------------------------------------
    const $ = (id) => document.getElementById(id);
    const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
    const PC_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const NOTE_TO_PC = Object.fromEntries(PC_NAMES.map((n,i)=>[n,i]));

    // Modes (scale degrees)
    const MODES = {
      major:      [0,2,4,5,7,9,11], // Ionian
      minor:      [0,2,3,5,7,8,10], // Aeolian
      dorian:     [0,2,3,5,7,9,10],
      phrygian:   [0,1,3,5,7,8,10],
      lydian:     [0,2,4,6,7,9,11],
      mixolydian: [0,2,4,5,7,9,10]
    };

    function midiToNoteName(m){
      const name = PC_NAMES[((m % 12) + 12) % 12];
      const oct = Math.floor(m / 12) - 1;
      return `${name}${oct}`;
    }

    function overlap(a0, a1, b0, b1){
      const lo = Math.max(a0, b0);
      const hi = Math.min(a1, b1);
      return Math.max(0, hi - lo);
    }

    // Mulberry32 PRNG (small + good enough for repeatable remix)
    function mulberry32(seed){
      let a = seed >>> 0;
      return function(){
        a |= 0; a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function makeRng(){
      const s = Number($("seed").value);
      if (Number.isFinite(s)) return mulberry32(s);
      return Math.random;
    }

    // ------------------------------------------------------------
    // UI helpers
    // ------------------------------------------------------------
    function setWarn(msg){
      const el = $("warn");
      if(!msg){ el.style.display="none"; el.textContent=""; return; }
      el.style.display="block"; el.textContent = msg;
    }
    function setOk(msg){
      const el = $("ok");
      if(!msg){ el.style.display="none"; el.textContent=""; return; }
      el.style.display="block"; el.textContent = msg;
    }
    function logLine(s){
      const el = $("log");
      if (el.textContent === "(upload a MIDI file or load an example)") el.textContent = "";
      el.textContent += (el.textContent ? "\n" : "") + s;
      el.scrollTop = el.scrollHeight;
    }
    function jumpTo(id){ $(id).scrollIntoView({behavior:"smooth", block:"start"}); }

    $("jumpDemo").addEventListener("click", (e)=>{ e.preventDefault(); jumpTo("demo"); });
    $("jumpStudy").addEventListener("click", (e)=>{ e.preventDefault(); jumpTo("study"); });
    $("jumpEvidence").addEventListener("click", (e)=>{ e.preventDefault(); jumpTo("evidence"); });

    // Tabs
    const tabUpload = $("tabUpload"), tabExamples = $("tabExamples"), tabSettings = $("tabSettings");
    const panelUpload = $("panelUpload"), panelExamples = $("panelExamples"), panelSettings = $("panelSettings");
    function setTab(which){
      [tabUpload, tabExamples, tabSettings].forEach(t => t.classList.remove("active"));
      panelUpload.style.display = "none";
      panelExamples.style.display = "none";
      panelSettings.style.display = "none";
      if(which==="upload"){ tabUpload.classList.add("active"); panelUpload.style.display = ""; }
      if(which==="examples"){ tabExamples.classList.add("active"); panelExamples.style.display = ""; }
      if(which==="settings"){ tabSettings.classList.add("active"); panelSettings.style.display = ""; }
    }
    tabUpload.addEventListener("click", ()=>setTab("upload"));
    tabExamples.addEventListener("click", ()=>setTab("examples"));
    tabSettings.addEventListener("click", ()=>setTab("settings"));

    // sliders display
    function syncSliders(){
      $("swingVal").textContent = Number($("swing").value).toFixed(2);
      $("humVal").textContent = Number($("humanize").value).toFixed(3);
      $("strengthVal").textContent = Number($("strength").value).toFixed(2);
    }
    $("swing").addEventListener("input", syncSliders);
    $("humanize").addEventListener("input", syncSliders);
    $("strength").addEventListener("input", syncSliders);
    syncSliders();

    // ------------------------------------------------------------
    // MIDI state
    // ------------------------------------------------------------
    let midiIn = null;
    let midiOut = null;

    let bpm = 120;
    let keyPc = 0;
    let modeName = "major";
    let beatsPerBar = 4;

    let melodyTrackIndex = -1;
    let melodyNotes = []; // from selected track

    // stats
    const statFile = $("statFile");
    const statBpm = $("statBpm");
    const statKey = $("statKey");
    const statTrack = $("statTrack");
    const statDur = $("statDur");

    // ------------------------------------------------------------
    // MIDI analysis
    // ------------------------------------------------------------
    function getFirstTempo(m){
      try{
        if (m?.header?.tempos?.length){
          const t = m.header.tempos[0];
          if (t && isFinite(t.bpm) && t.bpm > 0) return t.bpm;
        }
      }catch(e){}
      return 120;
    }

    function midiDurationSeconds(m){
      let maxT = 0;
      for (const tr of m.tracks){
        for (const n of tr.notes){
          maxT = Math.max(maxT, (n.time || 0) + (n.duration || 0));
        }
      }
      return maxT;
    }

    function pickMelodyTrack(m){
      // Heuristic: high average pitch, not too dense
      let best = -1;
      let bestScore = -Infinity;

      m.tracks.forEach((tr, idx) => {
        if (!tr.notes || tr.notes.length < 6) return;

        const notes = tr.notes;
        const avgMidi = notes.reduce((a,n)=>a+(n.midi||0),0)/notes.length;
        const dur = notes.reduce((a,n)=>a+(n.duration||0),0);
        const density = notes.length / Math.max(0.001, dur);

        const score = (avgMidi * 1.0) - (density * 25);
        if (score > bestScore){ bestScore = score; best = idx; }
      });

      if (best < 0){
        best = m.tracks.findIndex(t => t.notes && t.notes.length);
      }
      return best;
    }

    // Krumhansl-ish profiles (simple) to pick major vs minor + tonic
    const KS_MAJOR = [6.35,2.23,3.48,2.33,4.38,4.09,2.52,5.19,2.39,3.66,2.29,2.88];
    const KS_MINOR = [6.33,2.68,3.52,5.38,2.60,3.53,2.54,4.75,3.98,2.69,3.34,3.17];

    function rotate(arr, k){
      const n = arr.length;
      const out = new Array(n);
      for(let i=0;i<n;i++) out[i] = arr[(i-k+n)%n];
      return out;
    }

    function dot(a,b){
      let s=0;
      for(let i=0;i<a.length;i++) s += a[i]*b[i];
      return s;
    }

    function detectKeyAndModeFromNotes(notes){
      const hist = new Array(12).fill(0);
      for (const n of notes){
        const pc = ((n.midi ?? 0) % 12 + 12) % 12;
        const w = clamp(n.duration ?? 0.1, 0.01, 10);
        hist[pc] += w;
      }

      // normalize
      const sum = hist.reduce((a,b)=>a+b,0) || 1;
      const norm = hist.map(x=>x/sum);

      let best = { score:-Infinity, pc:0, mode:"major" };

      for(let pc=0; pc<12; pc++){
        const majScore = dot(norm, rotate(KS_MAJOR, pc));
        const minScore = dot(norm, rotate(KS_MINOR, pc));
        if (majScore > best.score) best = { score:majScore, pc, mode:"major" };
        if (minScore > best.score) best = { score:minScore, pc, mode:"minor" };
      }
      return best;
    }

    // ------------------------------------------------------------
    // Music theory helpers
    // ------------------------------------------------------------
    function scalePcs(tonicPc, mode){
      const arr = MODES[mode] || MODES.major;
      return arr.map(x => (x + tonicPc) % 12);
    }

    function pentatonicFromMode(tonicPc, mode){
      // Major pent: 1 2 3 5 6 ; Minor pent: 1 b3 4 5 b7
      if (mode === "minor" || mode === "phrygian"){
        const rel = [0,3,5,7,10];
        return rel.map(x => (x + tonicPc) % 12);
      }
      const rel = [0,2,4,7,9];
      return rel.map(x => (x + tonicPc) % 12);
    }

    function nearestPcInSet(targetPc, pcs){
      let bestPc = pcs[0];
      let bestDist = 999;
      for (const pc of pcs){
        let d = Math.abs(pc - targetPc);
        d = Math.min(d, 12 - d);
        if (d < bestDist){ bestDist = d; bestPc = pc; }
      }
      return bestPc;
    }

    function snapMidiToScale(midi, allowedPcs){
      const pc = ((midi % 12) + 12) % 12;
      if (allowedPcs.includes(pc)) return midi;

      // try shifting by semitones within +/- 2 first (gentle)
      for (let step=1; step<=2; step++){
        const up = (pc + step) % 12;
        const dn = (pc - step + 12) % 12;
        if (allowedPcs.includes(up)) return midi + step;
        if (allowedPcs.includes(dn)) return midi - step;
      }

      // fallback to nearest
      const bestPc = nearestPcInSet(pc, allowedPcs);
      // shift to nearest pc by smallest signed distance
      let bestShift = 0;
      let best = 999;
      for (let s=-6; s<=6; s++){
        if (((pc + s + 120) % 12) === bestPc){
          const ad = Math.abs(s);
          if (ad < best){ best = ad; bestShift = s; }
        }
      }
      return midi + bestShift;
    }

    function enforceTonicCadence(notes, tonicPc, mode, beatSec, bars, beatsPerBar){
      // Add/shape ending to land on tonic, and (lightly) starting on tonic.
      if (!notes.length) return notes;

      const barSec = beatsPerBar * beatSec;
      const totalSec = bars * barSec;

      // Start: if first note isn't tonic-ish, nudge by scale snap (handled earlier).
      // End: add a final tonic note (or resolve last note to tonic) near the end.
      const last = notes[notes.length-1];
      const lastPc = ((last.midi % 12) + 12) % 12;

      const allow = scalePcs(tonicPc, mode);
      const tonicMidiNear = (m) => {
        // keep octave similar
        const baseOct = Math.floor(m/12);
        let cand = baseOct*12 + tonicPc;
        // adjust to nearest octave to m
        while (cand - m > 6) cand -= 12;
        while (m - cand > 6) cand += 12;
        return clamp(cand, 36, 96);
      };

      const endTime = Math.max(0, totalSec - 1.0*beatSec);
      const endDur = 0.9*beatSec;

      // If last note is not tonic, gently resolve it.
      if (lastPc !== tonicPc){
        // shorten last note slightly so resolution reads
        last.duration = Math.min(last.duration ?? endDur, 0.6*beatSec);
        const resMidi = tonicMidiNear(last.midi);
        notes.push({
          midi: snapMidiToScale(resMidi, allow),
          time: Math.max(last.time + (last.duration ?? 0.2), endTime),
          duration: endDur,
          velocity: clamp((last.velocity ?? 0.82) + 0.06, 0.2, 1.0)
        });
      } else {
        // if already tonic, extend/anchor with a final longer tonic if needed
        if ((last.time ?? 0) < endTime){
          notes.push({
            midi: last.midi,
            time: endTime,
            duration: endDur,
            velocity: clamp((last.velocity ?? 0.82), 0.2, 1.0)
          });
        }
      }

      return notes;
    }

    // ------------------------------------------------------------
    // Remix engine (better theory: tonic cadence + inversions + broken chords + bass motion)
    // ------------------------------------------------------------
    function diatonicTriads(tonicPc, mode){
      const sc = scalePcs(tonicPc, mode);
      const chords = [];
      for (let d=0; d<7; d++){
        const pcs = [sc[d], sc[(d+2)%7], sc[(d+4)%7]];
        chords.push({ degree: d+1, pcs, rootPc: pcs[0] });
      }
      return chords;
    }

    function fitChordForWindow(notes, t0, t1, chords){
      const scores = chords.map(() => 0);
      for (const n of notes){
        const nt0 = n.time ?? 0;
        const nt1 = nt0 + (n.duration ?? 0.1);
        const ov = overlap(t0, t1, nt0, nt1);
        if (ov <= 0) continue;
        const pc = (n.midi ?? 0) % 12;
        chords.forEach((ch, i) => { if (ch.pcs.includes(pc)) scores[i] += ov; });
      }

      // small preference for tonic and dominant (to reduce random-sounding changes)
      chords.forEach((ch,i)=>{
        if (ch.degree === 1) scores[i] *= 1.10;
        if (ch.degree === 5) scores[i] *= 1.06;
      });

      let bestI = 0, best = -Infinity;
      for (let i=0; i<scores.length; i++){
        if (scores[i] > best){ best = scores[i]; bestI = i; }
      }
      return chords[bestI];
    }

    function buildChordMidiFromPcs(pcs, centerMidi){
      // Convert pcs to midi notes around a center, sorted
      const out = [];
      for (const pc of pcs){
        let m = centerMidi + ((pc - (centerMidi % 12) + 12) % 12);
        // shift into a pleasant range
        while (m < centerMidi-12) m += 12;
        while (m > centerMidi+12) m -= 12;
        out.push(m);
      }
      out.sort((a,b)=>a-b);
      return out;
    }

    function chooseBestInversion(prevVoiced, chordPcs, baseMidi){
      // Try 3 inversions by rotating chord tones +/- octaves, choose minimal movement
      const candidates = [];

      // base triad around baseMidi
      const base = buildChordMidiFromPcs(chordPcs, baseMidi);

      function score(voiced){
        if (!prevVoiced?.length) return 0;
        const a = [...prevVoiced].sort((x,y)=>x-y);
        const b = [...voiced].sort((x,y)=>x-y);

        // compare nearest pairs (truncate to min length)
        const k = Math.min(a.length, b.length);
        let s = 0;
        for (let i=0;i<k;i++) s += Math.abs(a[i]-b[i]);
        // penalize huge spreads
        const spread = (b[b.length-1] - b[0]);
        s += Math.max(0, spread - 18);
        return s;
      }

      // generate inversions by moving bottom note up octave
      let v = [...base];
      for (let inv=0; inv<3; inv++){
        candidates.push(v);
        // next inversion
        const next = [...v];
        next[0] += 12;
        next.sort((a,b)=>a-b);
        v = next;
      }

      candidates.sort((x,y)=>score(x)-score(y));
      return candidates[0];
    }

    function maybeAddExtensions(voiced, tonicPc, mode, rng, style, strength){
      // tasteful 7ths/9ths; more in lofi, less in baroque; edm uses stabs so keep tight
      if (style === "edm") return voiced;

      const sc = scalePcs(tonicPc, mode);
      const top = voiced[voiced.length-1];

      const extChance =
        style === "lofi" ? (0.45 + 0.25*strength) :
        style === "baroque" ? (0.15 + 0.10*strength) :
        (0.25 + 0.20*strength);

      if (rng() > extChance) return voiced;

      // choose 7th or 9th scale tone relative to chord root (diatonic-ish)
      const addType = (rng() < 0.60) ? "7" : "9";
      let add = top + (addType === "7" ? 10 : 14);

      const addPc = ((add % 12) + 12) % 12;
      // keep extension in scale
      const snappedPc = nearestPcInSet(addPc, sc);
      // shift add to snapped pc minimally
      for (let s=-2; s<=2; s++){
        const pc = ((add + s) % 12 + 12) % 12;
        if (pc === snappedPc){ add += s; break; }
      }
      if (add <= 88) return [...voiced, add].sort((a,b)=>a-b);
      return voiced;
    }

    function applyRhythmTransform(notes, style, beatSec, rng){
      const doRhythm = $("doRhythm").checked;
      if (!doRhythm) return notes.map(n => ({...n}));

      const swing = Number($("swing").value);
      const humanize = Number($("humanize").value);

      const quantGridBeats = (style === "edm") ? 0.25 : null; // 1/16
      const out = notes.map(n => ({...n}));

      for (const n of out){
        if (quantGridBeats){
          const gridSec = quantGridBeats * beatSec;
          n.time = Math.round((n.time ?? 0) / gridSec) * gridSec;
          n.duration = Math.max(gridSec * 0.9, n.duration ?? gridSec);
        }

        if (style === "lofi" && swing > 0){
          const b = (n.time ?? 0) / beatSec;
          const frac = b - Math.floor(b);
          if (Math.abs(frac - 0.5) < 0.07){
            n.time += (swing * 0.10) * beatSec;
          }
        }

        if (humanize > 0){
          const jitter = (rng()*2 - 1) * humanize;
          const jitter2 = (rng()*2 - 1) * humanize;
          n.time += jitter;
          n.duration = Math.max(0.03, (n.duration ?? 0.1) + jitter2);
          n.velocity = clamp((n.velocity ?? 0.75) + (rng()*2 - 1) * 0.06, 0.1, 1.0);
        }
      }
      return out;
    }

    function brokenChordPattern(voiced, style, beatSec, slotT0, slotT1, strength, rng){
      // Returns list of {midi,time,duration,velocity} for an arpeggiated chord
      const events = [];
      const barLen = slotT1 - slotT0;

      // step: faster for baroque, medium for lofi, stabs for edm (handled elsewhere)
      const step =
        style === "baroque" ? 0.5*beatSec :
        style === "lofi" ? 0.5*beatSec :
        0.25*beatSec;

      const dur = Math.max(0.03, step*0.90);

      // pattern selection
      const tri = voiced.slice(0,3);
      const upDown = (rng() < 0.55);
      const pat = upDown ? [0,1,2,1] : [0,1,2,0,2,1];

      let t = slotT0;
      let i = 0;
      while (t < slotT1 - 0.02){
        const idx = pat[i % pat.length];
        const m0 = tri[idx] ?? voiced[idx % voiced.length];
        events.push({
          midi: m0,
          time: t,
          duration: dur,
          velocity: 0.35 + 0.14*strength
        });
        t += step;
        i++;
      }
      return events;
    }

    function buildRemix(m){
      const rng = makeRng();
      const style = $("style").value;
      beatsPerBar = Number($("barsize").value) || 4;

      const strength = clamp(Number($("strength").value), 0, 1);
      bpm = getFirstTempo(m);
      const beatSec = 60 / Math.max(1, bpm);
      const barSec = beatsPerBar * beatSec;

      // key + mode
      const keyOverride = $("keyOverride").value;
      modeName = $("modeOverride").value;

      const detected = detectKeyAndModeFromNotes(melodyNotes);
      keyPc = (keyOverride === "auto") ? detected.pc : NOTE_TO_PC[keyOverride];

      // If user left key auto, keep detected major/minor as a default *unless* user picked a specific mode
      // (user mode should win; detected mode just affects display log and scale lock behavior).
      // We won't override modeName because user explicitly chose it in UI.

      const durSec = midiDurationSeconds(m);
      const bars = Math.max(1, Math.ceil(durSec / barSec));

      // Allowed pitch sets for melody/counter
      const diatonic = scalePcs(keyPc, modeName);
      const penta = pentatonicFromMode(keyPc, modeName);
      const preferPenta = $("preferPentatonic").checked;
      const melodicAllowed = preferPenta ? penta : diatonic;

      // Build chord plan from melody, then force tonic at start/end
      const chords = diatonicTriads(keyPc, modeName);
      const chordPlan = [];
      for (let b=0; b<bars; b++){
        const t0 = b * barSec;
        const t1 = (b+1) * barSec;
        const ch = fitChordForWindow(melodyNotes, t0, t1, chords);
        chordPlan.push({ bar: b, t0, t1, chord: ch });
      }

      // enforce tonic at start/end (start/end on tonic)
      const tonicChord = chords.find(c=>c.degree===1) || chords[0];
      chordPlan[0].chord = tonicChord;
      chordPlan[chordPlan.length-1].chord = tonicChord;

      const out = new Midi();
      try{ out.header.fromJSON(m.header.toJSON()); }
      catch(e){ try{ out.header.setTempo(bpm / 60); }catch(_){} }

      // Track: Melody (copy selected track only, with optional scale lock + cadence)
      const tMel = out.addTrack(); tMel.name = "Melody";

      let melCopy = melodyNotes.map(n => ({
        midi: n.midi, time: n.time, duration: n.duration, velocity: n.velocity ?? 0.85
      }));

      // Gentle scale lock (fix “sounds like shit” when input has stray notes)
      if ($("lockToScale").checked){
        melCopy = melCopy.map(n => ({
          ...n,
          midi: snapMidiToScale(n.midi, diatonic) // always use full diatonic for melody lock
        }));
      }

      melCopy = applyRhythmTransform(melCopy, style, beatSec, rng);
      melCopy = enforceTonicCadence(melCopy, keyPc, modeName, beatSec, bars, beatsPerBar);

      for (const n of melCopy){
        tMel.addNote({
          midi: clamp(Math.round(n.midi), 24, 108),
          time: Math.max(0, n.time),
          duration: Math.max(0.03, n.duration ?? 0.1),
          velocity: clamp(n.velocity ?? 0.85, 0.1, 1.0),
        });
      }

      // Harmony: use inversions (voice leading) + broken chords option by style/strength
      if ($("doChords").checked){
        const tCh = out.addTrack(); tCh.name = "Chords";

        let prevVoiced = null;
        for (const slot of chordPlan){
          const baseMidi =
            style === "edm" ? 60 :
            style === "baroque" ? 58 :
            60;

          let voiced = chooseBestInversion(prevVoiced, slot.chord.pcs, baseMidi);
          voiced = maybeAddExtensions(voiced, keyPc, modeName, rng, style, strength);

          // EDM: stabs (keep tight)
          if (style === "edm"){
            const stabDur = 0.42 * beatSec;
            const times = beatsPerBar === 3 ? [slot.t0, slot.t0 + 1.5*beatSec] : [slot.t0, slot.t0 + 2*beatSec];
            for (const tt of times){
              if (rng() < 0.08 * (1-strength)) continue;
              for (const m0 of voiced.slice(0,3)){
                tCh.addNote({ midi: m0, time: tt, duration: stabDur, velocity: 0.55 + 0.15*strength });
              }
            }
          } else {
            // Broken chords technique (always for baroque; often for lofi when strength higher)
            const useBroken =
              (style === "baroque") ||
              (style === "lofi" && strength > 0.35 && rng() < 0.75) ||
              (style === "lofi" && rng() < 0.45);

            if (useBroken){
              const ev = brokenChordPattern(voiced, style, beatSec, slot.t0, slot.t1, strength, rng);
              for (const e of ev){
                tCh.addNote({ midi: e.midi, time: e.time, duration: e.duration, velocity: e.velocity });
              }
            } else {
              const dur = Math.max(0.1, (slot.t1 - slot.t0) * 0.985);
              for (const m0 of voiced){
                tCh.addNote({ midi: m0, time: slot.t0, duration: dur, velocity: 0.34 + 0.16*strength });
              }
            }
          }

          prevVoiced = voiced.slice(0,3);
        }
      }

      // Bass: use inversion-aware bass + motion (approach tones / fifths / scale tones)
      if ($("doBass").checked){
        const tBa = out.addTrack(); tBa.name = "Bass";
        const diatonicSet = scalePcs(keyPc, modeName);

        let prevBass = null;

        for (let i=0;i<chordPlan.length;i++){
          const slot = chordPlan[i];
          const rootPc = slot.chord.rootPc;

          // pick a bass target: mostly root, sometimes fifth/third (inversion feel)
          const pickRoll = rng();
          let bassPc = rootPc;
          if (style !== "edm"){
            if (pickRoll < 0.18*strength) bassPc = slot.chord.pcs[1]; // 3rd
            else if (pickRoll < 0.40*strength) bassPc = (rootPc + 7) % 12; // 5th
          }

          // choose bass midi in a musical range
          let bassMidi = 36 + ((bassPc - (36 % 12) + 12) % 12);
          while (bassMidi < 30) bassMidi += 12;
          while (bassMidi > 50) bassMidi -= 12;

          bassMidi = clamp(bassMidi, 28, 55);

          if (style === "edm"){
            const step = 0.5 * beatSec; // 8ths
            let t = slot.t0;
            let k = 0;
            while (t < slot.t1 - 0.02){
              if (rng() < 0.10*(1-strength)) { t += step; k++; continue; }
              const isOff = (k % 2 === 1);
              const m0 = (isOff && rng() < (0.25*strength)) ? bassMidi + 12 : bassMidi;
              tBa.addNote({ midi: m0, time: t, duration: step*0.92, velocity: 0.68 + 0.20*strength });
              t += step; k++;
            }
          } else if (style === "baroque"){
            // walking bass with chord tones + passing scale tones
            const step = 0.5 * beatSec;
            const chordTones = slot.chord.pcs.map(pc => {
              let m0 = 36 + ((pc - 0 + 12) % 12);
              while (m0 < 30) m0 += 12;
              while (m0 > 52) m0 -= 12;
              return m0;
            }).sort((a,b)=>a-b);

            let t = slot.t0;
            let k = 0;
            while (t < slot.t1 - 0.02){
              let m0 = chordTones[k % chordTones.length];
              // occasional passing tone
              if (rng() < 0.35*strength){
                const pc = ((m0 % 12) + 12) % 12;
                const passPc = diatonicSet[(diatonicSet.indexOf(pc)+1+7)%7] ?? pc;
                let pass = m0 + (((passPc - pc + 12) % 12) <= 6 ? ((passPc - pc + 12)%12) : -((pc - passPc + 12)%12));
                pass = clamp(pass, 28, 55);
                m0 = pass;
              }
              tBa.addNote({ midi: clamp(m0, 28, 55), time: t, duration: step*0.92, velocity: 0.58 + 0.15*strength });
              t += step; k++;
            }
          } else {
            // Lofi: root + fifth + approach to next bar’s bass
            const half = (beatsPerBar/2) * beatSec;

            const fifthPc = (rootPc + 7) % 12;
            let fifthMidi = 36 + ((fifthPc - (36 % 12) + 12) % 12);
            fifthMidi = clamp(fifthMidi, 28, 55);

            tBa.addNote({ midi: bassMidi, time: slot.t0, duration: half*0.98, velocity: 0.52 + 0.12*strength });

            if (strength > 0.18){
              tBa.addNote({ midi: fifthMidi, time: slot.t0 + half, duration: (half*0.80), velocity: 0.50 + 0.10*strength });
            }

            // approach tone into next bar (smooth movement)
            if (strength > 0.30 && i < chordPlan.length-1){
              const nextRootPc = chordPlan[i+1].chord.rootPc;
              let nextMidi = 36 + ((nextRootPc - (36 % 12) + 12) % 12);
              nextMidi = clamp(nextMidi, 28, 55);

              // approach by a diatonic step if possible
              let approach = nextMidi;
              if (prevBass != null){
                // step toward next
                const dir = (nextMidi >= bassMidi) ? +1 : -1;
                approach = nextMidi - dir*1; // chromatic approach
                // keep approach within diatonic if possible
                const apPc = ((approach%12)+12)%12;
                if (!diatonicSet.includes(apPc)){
                  // try +/-1
                  if (diatonicSet.includes((apPc+1)%12)) approach += 1;
                  else if (diatonicSet.includes((apPc+11)%12)) approach -= 1;
                }
                approach = clamp(approach, 28, 55);
              }

              tBa.addNote({
                midi: approach,
                time: slot.t1 - 0.5*beatSec,
                duration: 0.45*beatSec,
                velocity: 0.46 + 0.10*strength
              });
            }
          }

          prevBass = bassMidi;
        }
      }

      // Counter-melody: prefer consonant intervals + (optionally) pentatonic tones
      if ($("doCounter").checked){
        const tCo = out.addTrack(); tCo.name = "Counter";

        const diatonic = scalePcs(keyPc, modeName);
        const allow = ($("preferPentatonic").checked) ? pentatonicFromMode(keyPc, modeName) : diatonic;
        const allowSet = new Set(allow);

        const consonant = [3,4,7,8,9]; // 3rds/5ths/6ths

        const durGrid = (style === "edm") ? 0.25 * beatSec : 0.5 * beatSec;
        const durNote = durGrid * 0.92;

        const total = bars * barSec;

        for (let t=0; t<total; t += durGrid){
          // find active melody at time t
          let mel = null;
          for (const n of melCopy){
            const t0 = n.time ?? 0;
            const t1 = t0 + (n.duration ?? 0.1);
            if (t >= t0 && t < t1){ mel = n; break; }
          }
          if (!mel) continue;

          const density = (style === "baroque") ? (0.42*strength) : (0.55*strength);
          if (rng() < (1 - density)) continue;

          const base = clamp(Math.round(mel.midi), 48, 84);
          let choices = [];

          for (const iv of consonant){
            for (const dir of [-1, +1]){
              const m0 = base + dir*iv;
              const pc = ((m0 % 12) + 12) % 12;
              if (allowSet.has(pc)) choices.push(m0);
            }
          }

          // also allow a “single note melody” trick sometimes (monotony over moving harmony)
          if (rng() < 0.10 + 0.20*strength){
            const pc = ((base % 12) + 12) % 12;
            if (allowSet.has(pc)) choices.push(base);
          }

          if (!choices.length) continue;

          // generally above melody, avoid extreme highs
          choices = choices.filter(x => x >= base && x <= 88);
          if (!choices.length) continue;

          // “big leap” occasionally (major 6th-ish) but still in allowed
          if (rng() < 0.06*strength){
            const leap = base + 9;
            const pc = ((leap % 12) + 12) % 12;
            if (allowSet.has(pc)) choices.push(leap);
          }

          const m0 = clamp(choices[Math.floor(rng()*choices.length)], 52, 90);
          tCo.addNote({ midi: m0, time: t, duration: durNote, velocity: 0.32 + 0.18*strength });
        }
      }

      // final rhythm pass across generated tracks
      if ($("doRhythm").checked){
        for (const tr of out.tracks){
          const notes = tr.notes.map(n => ({ midi:n.midi, time:n.time, duration:n.duration, velocity:n.velocity ?? 0.7 }));
          tr.notes = applyRhythmTransform(notes, style, beatSec, rng).map(n => ({
            midi: clamp(Math.round(n.midi), 24, 108),
            time: Math.max(0, n.time),
            duration: Math.max(0.03, n.duration),
            velocity: clamp(n.velocity ?? 0.7, 0.1, 1.0),
          }));
        }
      }

      return { out, info: { bpm, key: `${PC_NAMES[keyPc]} ${modeName}`, bars, style, duration: durSec, strength } };
    }

    // ------------------------------------------------------------
    // Tone.js playback (nicer sound)
    // ------------------------------------------------------------
    let audioReady = false;
    let lead, pad, bassSynth, counter;
    let master, comp, reverb, chorus, limiter;
    let part = null;

    async function ensureAudio(){
      if (Tone.context.state !== "running") await Tone.start();
      if (audioReady) return;

      master = new Tone.Gain(0.95).toDestination();

      comp = new Tone.Compressor({ threshold: -20, ratio: 3, attack: 0.01, release: 0.15 });
      limiter = new Tone.Limiter(-1);

      chorus = new Tone.Chorus({ frequency: 1.2, delayTime: 3.5, depth: 0.3, wet: 0.18 }).start();
      reverb = new Tone.Reverb({ decay: 2.8, preDelay: 0.01, wet: 0.16 });

      // routing
      chorus.connect(reverb);
      reverb.connect(comp);
      comp.connect(limiter);
      limiter.connect(master);

      function toFX(node){
        node.connect(chorus);
        node.connect(comp);
      }

      lead = new Tone.PolySynth(Tone.FMSynth, {
        volume: -12,
        options: {
          harmonicity: 1.8,
          modulationIndex: 8,
          envelope: { attack: 0.01, decay: 0.12, sustain: 0.20, release: 0.9 },
          modulationEnvelope: { attack: 0.02, decay: 0.2, sustain: 0.0, release: 0.2 }
        }
      });

      pad = new Tone.PolySynth(Tone.AMSynth, {
        volume: -16,
        options: {
          oscillator: { type: "sawtooth" },
          envelope: { attack: 0.12, decay: 0.25, sustain: 0.75, release: 1.6 }
        }
      });

      bassSynth = new Tone.MonoSynth({
        volume: -10,
        oscillator: { type: "sine" },
        filter: { Q: 1, type: "lowpass", rolloff: -24, frequency: 900 },
        envelope: { attack: 0.01, decay: 0.12, sustain: 0.6, release: 0.18 },
        filterEnvelope: { attack: 0.01, decay: 0.12, sustain: 0.0, release: 0.1, baseFrequency: 70, octaves: 2.3 }
      });

      counter = new Tone.PolySynth(Tone.Synth, {
        volume: -18,
        oscillator: { type: "triangle" },
        envelope: { attack: 0.01, decay: 0.06, sustain: 0.16, release: 0.35 }
      });

      toFX(lead);
      toFX(pad);
      toFX(counter);
      bassSynth.connect(comp);
      bassSynth.connect(reverb);

      audioReady = true;
    }

    function stopPlayback(){
      if (part){ try{part.stop(); part.dispose();}catch(e){} part=null; }
      Tone.Transport.stop();
      Tone.Transport.cancel();
      Tone.Transport.position = 0;
      $("stopBtn").disabled = true;
      $("abStopBtn").disabled = true;
    }

    function flattenNotesWithTrackName(m){
      const all = [];
      for (const tr of m.tracks){
        const tname = (tr.name || "").toLowerCase();
        for (const n of tr.notes){
          all.push({
            midi: n.midi,
            time: n.time ?? 0,
            duration: n.duration ?? 0.1,
            velocity: n.velocity ?? 0.8,
            track: tname
          });
        }
      }
      all.sort((a,b)=>a.time-b.time);
      return all;
    }

    function pickSynthForTrack(name){
      if (name.includes("bass")) return "bass";
      if (name.includes("chord") || name.includes("pad")) return "pad";
      if (name.includes("counter")) return "counter";
      return "lead";
    }

    function playMidi(m){
      stopPlayback();
      const notes = flattenNotesWithTrackName(m);
      if (!notes.length) return;

      Tone.Transport.stop();
      Tone.Transport.cancel();
      Tone.Transport.position = 0;

      const events = notes.map(n => ({
        time: Math.max(0, n.time),
        midi: clamp(Math.round(n.midi), 24, 108),
        dur: Math.max(0.03, n.duration),
        vel: clamp(n.velocity ?? 0.8, 0.1, 1.0),
        synth: pickSynthForTrack(n.track)
      }));

      part = new Tone.Part((time, v) => {
        const note = midiToNoteName(v.midi);
        if (v.synth === "bass"){
          bassSynth.triggerAttackRelease(note, v.dur, time, v.vel);
        } else if (v.synth === "pad"){
          pad.triggerAttackRelease(note, v.dur, time, v.vel);
        } else if (v.synth === "counter"){
          counter.triggerAttackRelease(note, v.dur, time, v.vel);
        } else {
          lead.triggerAttackRelease(note, v.dur, time, v.vel);
        }
      }, events);

      part.start(0);
      Tone.Transport.start("+0.02");
    }

    // ------------------------------------------------------------
    // Load MIDI (file or example)
    // ------------------------------------------------------------
    function updateReadyState(){
      const ok = !!midiIn;
      $("remixBtn").disabled = !ok;
      $("playOrigBtn").disabled = !ok;
      $("abStartBtn").disabled = !(midiIn && midiOut);
      $("playRemixBtn").disabled = !midiOut;
      $("downloadBtn").disabled = !midiOut;
    }

    function setStats({fileName, bpm, key, trackName, trackIndex, durSec}){
      statFile.textContent = fileName || "—";
      statBpm.textContent = bpm ? `${Math.round(bpm)} BPM` : "—";
      statKey.textContent = key || "—";
      statTrack.textContent = (trackIndex != null && trackIndex >= 0)
        ? `#${trackIndex+1} (${trackName || "unnamed"})`
        : "—";
      statDur.textContent = (durSec != null) ? `${durSec.toFixed(2)}s` : "—";
    }

    function parseMidiArrayBuffer(buf, fileName){
      $("log").textContent = "";
      setWarn(null); setOk(null);
      midiOut = null;

      midiIn = new Midi(buf);

      bpm = getFirstTempo(midiIn);
      melodyTrackIndex = pickMelodyTrack(midiIn);
      const tr = midiIn.tracks[melodyTrackIndex];
      melodyNotes = (tr?.notes || []).map(n => ({
        midi: n.midi, time: n.time ?? 0, duration: n.duration ?? 0.1, velocity: n.velocity ?? 0.85
      }));

      const dur = midiDurationSeconds(midiIn);
      const det = detectKeyAndModeFromNotes(melodyNotes);

      logLine(`Loaded: ${fileName || "MIDI"}`);
      logLine(`Tempo: ~${Math.round(bpm)} BPM`);
      logLine(`Picked melody track: ${melodyTrackIndex+1} (${tr?.name || "unnamed"})`);
      logLine(`Melody notes: ${melodyNotes.length}`);
      logLine(`Duration: ${dur.toFixed(2)} seconds`);
      logLine(`Key guess: ${PC_NAMES[det.pc]} (${det.mode} leaning)`);
      logLine(`Tip: you can override Key/Mode in Settings.`);
      logLine(`Next: Click “Create Remix”.`);

      setStats({
        fileName: fileName || "MIDI",
        bpm,
        key: `${PC_NAMES[det.pc]} (guess)`,
        trackName: tr?.name,
        trackIndex: melodyTrackIndex,
        durSec: dur
      });

      updateReadyState();
      refreshABUI();
      renderABTable();
      renderEvidence();
    }

    $("midiFile").addEventListener("change", async () => {
      const f = $("midiFile").files?.[0];
      if(!f){ midiIn=null; midiOut=null; updateReadyState(); return; }
      try{
        const buf = await f.arrayBuffer();
        parseMidiArrayBuffer(buf, f.name);
      }catch(e){
        console.error(e);
        setWarn("Failed to parse MIDI. Try a different .mid file.");
        midiIn=null; midiOut=null;
        updateReadyState();
      }
    });

    // Built-in examples
    function addNote(track, midi, time, dur, vel=0.85){
      track.addNote({ midi, time: Math.max(0,time), duration: Math.max(0.03,dur), velocity: clamp(vel,0.1,1) });
    }
    function makeExampleMidi(which, tempoBpm, bars){
      const m = new Midi();
      try{ m.header.setTempo(tempoBpm / 60); }
      catch(e){ try{ m.header.tempos = [{ bpm: tempoBpm, time: 0 }]; }catch(_){ } }

      const t = m.addTrack();
      t.name = "Example Melody";

      const beat = 60 / Math.max(1, tempoBpm);
      const bar = 4 * beat;
      const totalBars = clamp(Number(bars)||8, 2, 16);

      let seq = [];
      if (which === "minor"){
        seq = [69,72,76,79,76,74,72,69]; // A minor-ish
      } else if (which === "riff"){
        seq = [62,64,66,69,67,66,64,62]; // D mixo-ish
      } else {
        seq = [60,64,67,69,67,64,62,60]; // C major-ish
      }

      for (let b=0; b<totalBars; b++){
        const t0 = b * bar;
        for (let i=0; i<8; i++){
          const n = seq[i % seq.length];
          const time = t0 + i*(0.5*beat);
          const dur = 0.45*beat;
          const vel = 0.8 + 0.1*Math.sin((b+i)*0.7);
          if (which==="riff" && (i===2 || i===6) && (b%2===1)) continue;
          addNote(t, n, time, dur, vel);
        }
      }
      return m;
    }

    $("loadExampleBtn").addEventListener("click", () => {
      setWarn(null); setOk(null);
      try{
        const pick = $("examplePick").value;
        const tempo = clamp(Number($("exTempo").value)||110, 40, 220);
        const bars = clamp(Number($("exBars").value)||8, 2, 16);
        const m = makeExampleMidi(pick, tempo, bars);
        const bytes = m.toArray();
        parseMidiArrayBuffer(new Uint8Array(bytes).buffer, `Built-in: ${pick} (${tempo}bpm)`);
        setOk("Loaded built-in example. Now create a remix.");
      }catch(e){
        console.error(e);
        setWarn("Failed to load example (unexpected).");
      }
    });

    // ------------------------------------------------------------
    // Remix + download
    // ------------------------------------------------------------
    $("remixBtn").addEventListener("click", () => {
      setWarn(null); setOk(null);
      if (!midiIn) return;

      stopPlayback();
      logLine("—");
      logLine("Creating remix…");

      try{
        const { out, info } = buildRemix(midiIn);
        midiOut = out;

        logLine(`Style: ${info.style}`);
        logLine(`Key/Mode: ${info.key}`);
        logLine(`Bars: ${info.bars}`);
        logLine(`Strength: ${info.strength.toFixed(2)}`);
        logLine(`Tracks out: ${midiOut.tracks.length}`);
        logLine("Done. Preview and download the remix (and A/B test if you want).");

        statBpm.textContent = `${Math.round(info.bpm)} BPM`;
        statKey.textContent = info.key;
        statDur.textContent = `${info.duration.toFixed(2)}s`;

        updateReadyState();
        setOk("Remix created.");

      }catch(e){
        console.error(e);
        setWarn(e?.message || "Remix failed. Check console.");
        midiOut = null;
        updateReadyState();
      }
    });

    $("downloadBtn").addEventListener("click", () => {
      if (!midiOut) return;
      try{
        const bytes = midiOut.toArray();
        const blob = new Blob([bytes], { type: "audio/midi" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "remix_assistant_output.mid";
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
        setOk("Downloaded remix MIDI.");
      }catch(e){
        console.error(e);
        setWarn("Download failed. Try remixing again.");
      }
    });

    // ------------------------------------------------------------
    // Playback buttons
    // ------------------------------------------------------------
    $("playOrigBtn").addEventListener("click", async () => {
      if (!midiIn) return;
      setWarn(null);
      try{ await ensureAudio(); playMidi(midiIn); $("stopBtn").disabled = false; }
      catch(e){ console.error(e); setWarn("Audio failed to start. Click play again (browser audio policy)."); }
    });

    $("playRemixBtn").addEventListener("click", async () => {
      if (!midiOut) return;
      setWarn(null);
      try{ await ensureAudio(); playMidi(midiOut); $("stopBtn").disabled = false; }
      catch(e){ console.error(e); setWarn("Audio failed to start. Click play again (browser audio policy)."); }
    });

    $("stopBtn").addEventListener("click", stopPlayback);

    // ------------------------------------------------------------
    // Keyboard shortcuts
    // ------------------------------------------------------------
    window.addEventListener("keydown", (e) => {
      const tag = (document.activeElement?.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea" || tag === "select") return;

      if (e.code === "Space"){ e.preventDefault(); stopPlayback(); }
      else if (e.key.toLowerCase() === "r"){ if (!$("remixBtn").disabled) $("remixBtn").click(); }
      else if (e.key.toLowerCase() === "o"){ if (!$("playOrigBtn").disabled) $("playOrigBtn").click(); }
      else if (e.key.toLowerCase() === "p"){ if (!$("playRemixBtn").disabled) $("playRemixBtn").click(); }
    });

    // ------------------------------------------------------------
    // A/B Study storage + UI
    // ------------------------------------------------------------
    const AB_KEY = "liam_remix_ab_results_v1";
    function loadAB(){ try{ return JSON.parse(localStorage.getItem(AB_KEY) || "[]"); }catch(e){ return []; } }
    function saveAB(list){ localStorage.setItem(AB_KEY, JSON.stringify(list)); }

    function fmtWhen(iso){
      try{
        const d = new Date(iso);
        return d.toLocaleString(undefined, { month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
      }catch(e){ return iso; }
    }

    // star widgets
    function makeStarRow(containerId, onChange){
      const wrap = $(containerId);
      wrap.innerHTML = "";
      const stars = [];
      for(let i=1;i<=5;i++){
        const s = document.createElement("div");
        s.className = "star";
        s.textContent = "★";
        s.dataset.s = String(i);
        s.addEventListener("click", ()=>{
          stars.forEach(el => el.classList.toggle("on", Number(el.dataset.s) <= i));
          onChange(i);
        });
        wrap.appendChild(s);
        stars.push(s);
      }
      return {
        set: (n) => stars.forEach(el => el.classList.toggle("on", Number(el.dataset.s) <= n)),
        get: () => stars.filter(el => el.classList.contains("on")).length
      };
    }

    let qStars = 0, cStars = 0, coStars = 0;
    const qRow = makeStarRow("starsQuality", (n)=>{ qStars=n; refreshABUI(); });
    const cRow = makeStarRow("starsCreativity", (n)=>{ cStars=n; refreshABUI(); });
    const coRow = makeStarRow("starsCoherence", (n)=>{ coStars=n; refreshABUI(); });

    // A/B mapping state (randomized)
    let abActive = false;
    let abId = null;
    let mapA = null; // "orig" | "remix"
    let mapB = null;

    function newABId(){
      const s = Math.random().toString(16).slice(2, 10);
      return `ab_${Date.now().toString(16)}_${s}`;
    }

    function refreshABUI(){
      $("abId").textContent = abId || "—";
      $("abMap").textContent = (!abActive) ? "Hidden" : "Hidden";
      $("abRevealBtn").disabled = !abActive;
      $("playAB_A").disabled = !abActive;
      $("playAB_B").disabled = !abActive;
      $("abStopBtn").disabled = !abActive;

      const pref = $("pref").value;
      const canSave = abActive && pref && qStars>0 && cStars>0 && coStars>0;
      $("saveABBtn").disabled = !canSave;
    }

    $("abStartBtn").addEventListener("click", () => {
      if (!midiIn || !midiOut) return;
      setWarn(null); setOk(null);
      abActive = true;
      abId = newABId();

      if (Math.random() < 0.5){
        mapA = "orig"; mapB = "remix";
      } else {
        mapA = "remix"; mapB = "orig";
      }

      $("pref").value = "";
      qStars = 0; cStars = 0; coStars = 0;
      qRow.set(0); cRow.set(0); coRow.set(0);
      $("abComment").value = "";
      $("abMap").textContent = "Hidden";

      setOk("A/B test started. Play A and B, then submit.");
      refreshABUI();
    });

    $("abRevealBtn").addEventListener("click", () => {
      if (!abActive) return;
      $("abMap").textContent = `A=${mapA.toUpperCase()} • B=${mapB.toUpperCase()}`;
    });

    $("playAB_A").addEventListener("click", async () => {
      if (!abActive) return;
      try{
        await ensureAudio();
        playMidi(mapA === "orig" ? midiIn : midiOut);
        $("abStopBtn").disabled = false;
      }catch(e){
        console.error(e);
        setWarn("Audio failed to start. Click play again.");
      }
    });

    $("playAB_B").addEventListener("click", async () => {
      if (!abActive) return;
      try{
        await ensureAudio();
        playMidi(mapB === "orig" ? midiIn : midiOut);
        $("abStopBtn").disabled = false;
      }catch(e){
        console.error(e);
        setWarn("Audio failed to start. Click play again.");
      }
    });

    $("abStopBtn").addEventListener("click", stopPlayback);

    $("pref").addEventListener("change", refreshABUI);

    function currentConditionSnapshot(){
      return {
        style: $("style").value,
        strength: Number($("strength").value),
        swing: Number($("swing").value),
        humanize: Number($("humanize").value),
        keyOverride: $("keyOverride").value,
        mode: $("modeOverride").value,
        barsize: $("barsize").value,
        lockToScale: $("lockToScale").checked,
        preferPentatonic: $("preferPentatonic").checked
      };
    }

    $("saveABBtn").addEventListener("click", () => {
      if (!abActive) return;
      const pref = $("pref").value;
      if (!pref || qStars<=0 || cStars<=0 || coStars<=0) return;

      const chosen = pref === "tie" ? "tie" : (pref === "A" ? mapA : mapB);
      const entry = {
        ts: new Date().toISOString(),
        abId,
        mapping: { A: mapA, B: mapB },
        pref,
        chosen,
        ratings: { quality: qStars, creativity: cStars, coherence: coStars },
        comment: ($("abComment").value || "").trim(),
        file: statFile.textContent || "",
        bpm: bpm,
        keyGuess: statKey.textContent || "",
        condition: currentConditionSnapshot()
      };

      const list = loadAB();
      list.push(entry);
      saveAB(list);

      setOk("Saved A/B result. Evidence plots updated.");
      abActive = false;
      abId = null; mapA=null; mapB=null;
      refreshABUI();
      renderABTable();
      renderEvidence();
    });

    $("clearABBtn").addEventListener("click", () => {
      localStorage.removeItem(AB_KEY);
      setOk("Cleared local A/B results.");
      renderABTable();
      renderEvidence();
    });

    function exportCSV(filename, rows){
      const csv = rows.map(r => r.map(v => `"${String(v ?? "").replaceAll('"','""')}"`).join(",")).join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    $("exportABBtn").addEventListener("click", () => {
      const list = loadAB();
      if (!list.length){ setWarn("No A/B results to export yet."); return; }

      const header = [
        "ts","abId","pref","chosen","mapA","mapB",
        "quality","creativity","coherence",
        "style","strength","swing","humanize","mode","keyOverride","barsize",
        "lockToScale","preferPentatonic",
        "file","bpm","keyGuess","comment"
      ];

      const rows = [header];
      for (const r of list){
        rows.push([
          r.ts, r.abId, r.pref, r.chosen, r.mapping?.A, r.mapping?.B,
          r.ratings?.quality, r.ratings?.creativity, r.ratings?.coherence,
          r.condition?.style, r.condition?.strength, r.condition?.swing, r.condition?.humanize,
          r.condition?.mode, r.condition?.keyOverride, r.condition?.barsize,
          r.condition?.lockToScale, r.condition?.preferPentatonic,
          r.file, r.bpm, r.keyGuess, r.comment
        ]);
      }
      exportCSV("remix_ab_results.csv", rows);
      setOk("Exported A/B results CSV.");
    });

    function renderABTable(){
      const list = loadAB();
      const body = $("abTable");
      if (!list.length){
        body.innerHTML = `<tr><td colspan="3" class="tiny">No study results yet.</td></tr>`;
        return;
      }
      const view = list.slice(-10).reverse();
      body.innerHTML = view.map(r => {
        const winner = r.chosen === "tie" ? "Tie" : (r.chosen === "remix" ? "Remix" : "Original");
        const cond = `${r.condition?.style || "—"} • ${r.condition?.mode || "—"} • strength ${Number(r.condition?.strength ?? 0).toFixed(2)} • bpm ${Math.round(r.bpm || 0)}`;
        return `
          <tr>
            <td class="tiny">${fmtWhen(r.ts)}</td>
            <td><strong>${winner}</strong></td>
            <td class="tiny">${cond}</td>
          </tr>
        `;
      }).join("");
    }

    // ------------------------------------------------------------
    // Evidence plots (simple canvas charts)
    // ------------------------------------------------------------
    function fitCanvas(canvas, cssH){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = Math.max(320, Math.floor(canvas.getBoundingClientRect().width));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(cssH * dpr);
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return { ctx, w, h: cssH };
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function barChart(canvas, title, labels, values, options={}){
      const { ctx, w, h } = fitCanvas(canvas, 220);
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = "rgba(6,6,16,0.82)";
      ctx.fillRect(0,0,w,h);

      const padL = 46, padR = 12, padT = 30, padB = 44;
      const innerW = w - padL - padR;
      const innerH = h - padT - padB;

      ctx.fillStyle = "rgba(238,240,255,0.90)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText(title, 12, 18);

      const maxV = Math.max(1e-9, ...values);
      const n = values.length;
      const gap = 10;
      const barW = Math.max(10, (innerW - gap*(n-1)) / n);

      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, padT + innerH);
      ctx.lineTo(padL + innerW, padT + innerH);
      ctx.stroke();

      ctx.fillStyle = "rgba(238,240,255,0.60)";
      ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto";
      for(let t=0; t<=2; t++){
        const v = maxV * (t/2);
        const y = padT + innerH - innerH*(t/2);
        ctx.fillText((options.percent ? `${Math.round(v*100)}%` : v.toFixed(1).replace(".0","")), 10, y+4);
        ctx.strokeStyle = "rgba(255,255,255,0.06)";
        ctx.beginPath();
        ctx.moveTo(padL, y);
        ctx.lineTo(padL + innerW, y);
        ctx.stroke();
      }

      for(let i=0;i<n;i++){
        const v = values[i];
        const bh = (v/maxV)*innerH;
        const x = padL + i*(barW+gap);
        const y = padT + innerH - bh;

        ctx.fillStyle = options.alt && options.alt[i] ? "rgba(120,255,200,0.26)" : "rgba(200,120,255,0.30)";
        ctx.strokeStyle = options.alt && options.alt[i] ? "rgba(120,255,200,0.70)" : "rgba(200,120,255,0.78)";
        roundRect(ctx, x, y, barW, bh, 10);
        ctx.fill(); ctx.stroke();

        ctx.save();
        ctx.translate(x + barW/2, padT + innerH + 18);
        ctx.rotate(-0.25);
        ctx.textAlign = "center";
        ctx.fillStyle = "rgba(238,240,255,0.70)";
        ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto";
        ctx.fillText(labels[i], 0, 0);
        ctx.restore();
      }
    }

    function renderEvidence(){
      const list = loadAB();
      $("nTests").textContent = String(list.length);

      const remixWins = list.filter(r => r.chosen === "remix").length;
      const origWins  = list.filter(r => r.chosen === "orig").length;
      const ties      = list.filter(r => r.chosen === "tie").length;

      const totalNoTies = Math.max(1, remixWins + origWins);
      const remixWinPct = (remixWins / totalNoTies);
      $("remixWinPct").textContent = `${Math.round(remixWinPct*100)}%`;

      barChart(
        $("plotPref"),
        "Preference outcomes (count)",
        ["Remix", "Original", "Tie"],
        [remixWins, origWins, ties],
        { alt: [true,false,false] }
      );

      function avgFor(winner, key){
        const rows = list.filter(r => r.chosen === winner);
        if (!rows.length) return 0;
        return rows.reduce((a,r)=>a + (r.ratings?.[key] || 0),0) / rows.length;
      }
      const avgRemixQ = avgFor("remix","quality");
      const avgOrigQ  = avgFor("orig","quality");
      const avgRemixC = avgFor("remix","creativity");
      const avgOrigC  = avgFor("orig","creativity");
      const avgRemixCo= avgFor("remix","coherence");
      const avgOrigCo = avgFor("orig","coherence");

      barChart(
        $("plotAvg"),
        "Average ratings by winner (1–5)",
        ["Q Remix","Q Orig","Cr Remix","Cr Orig","Co Remix","Co Orig"],
        [avgRemixQ, avgOrigQ, avgRemixC, avgOrigC, avgRemixCo, avgOrigCo],
        { alt: [true,false,true,false,true,false] }
      );

      const styles = ["lofi","edm","baroque"];
      const styleLabels = ["Lofi","EDM","Baroque"];
      const styleRates = styles.map(s => {
        const rows = list.filter(r => (r.condition?.style === s) && r.chosen !== "tie");
        if (!rows.length) return 0;
        const wins = rows.filter(r => r.chosen === "remix").length;
        return wins / rows.length;
      });
      barChart($("plotStyle"), "Remix win-rate by style", styleLabels, styleRates, { percent:true, alt:[true,true,true] });

      const buckets = ["0.0–0.25","0.25–0.5","0.5–0.75","0.75–1.0"];
      const bucketRates = buckets.map((_,i)=>{
        const lo = i*0.25;
        const hi = (i+1)*0.25 + 1e-9;
        const rows = list.filter(r => {
          const st = Number(r.condition?.strength ?? 0);
          return st >= lo && st < hi && r.chosen !== "tie";
        });
        if (!rows.length) return 0;
        const wins = rows.filter(r => r.chosen === "remix").length;
        return wins / rows.length;
      });
      barChart($("plotStrength"), "Remix win-rate by strength bucket", buckets, bucketRates, { percent:true, alt:[true,true,true,true] });

      const stylePairs = styleLabels.map((lab,i)=>({lab, rate: styleRates[i]})).sort((a,b)=>b.rate-a.rate);
      $("bestStyle").textContent = stylePairs[0]?.lab || "—";
      const bestBucketIdx = bucketRates.map((v,i)=>({v,i})).sort((a,b)=>b.v-a.v)[0]?.i ?? null;
      $("bestStrength").textContent = (bestBucketIdx == null) ? "—" : buckets[bestBucketIdx];
    }

    window.addEventListener("resize", renderEvidence);

    // ------------------------------------------------------------
    // Initial render
    // ------------------------------------------------------------
    function updateAll(){
      updateReadyState();
      refreshABUI();
      renderABTable();
      renderEvidence();
    }
    updateAll();

    // Ensure AB enabled after remix
    $("remixBtn").addEventListener("click", ()=>{ setTimeout(()=>{ updateReadyState(); refreshABUI(); }, 0); });

    // Monitor slider labels
    ["style","barsize","strength","swing","humanize","keyOverride","modeOverride","lockToScale","preferPentatonic"].forEach(id=>{
      $(id).addEventListener("change", ()=>{ syncSliders(); });
      $(id).addEventListener("input", ()=>{ syncSliders(); });
    });
  </script>
</body>
</html>

