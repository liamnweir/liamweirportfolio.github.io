<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Remix Assistant (MIDI) | Liam Weir</title>

  <!-- Tone.js playback -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
  <!-- MIDI parse + write (browser) -->
  <script src="https://unpkg.com/@tonejs/midi"></script>

  <style>
    :root{
      --bg0:#070712;
      --bg1:#0b0820;
      --bg2:#120a2c;
      --panel: rgba(255,255,255,.055);
      --panel2: rgba(255,255,255,.038);
      --border: rgba(255,255,255,.12);
      --text:#eef0ff;
      --muted:rgba(238,240,255,.78);
      --muted2:rgba(238,240,255,.62);
      --shadow: 0 30px 70px rgba(0,0,0,.52);
      --r: 18px;

      --redA: rgba(255, 90, 120, .22);
      --redB: rgba(255, 140, 80, .16);
      --redBorder: rgba(255, 90, 120, .55);

      --greenA: rgba(80, 255, 170, .18);
      --greenB: rgba(60, 220, 140, .12);
      --greenBorder: rgba(80, 255, 170, .48);

      --ok: rgba(120,255,190,.14);
      --okBorder: rgba(120,255,190,.28);
      --warnBg: rgba(255,170,120,.10);
      --warnBorder: rgba(255,170,120,.32);

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--text);
      background:
        radial-gradient(900px 520px at 18% -10%, rgba(255, 90, 120, .20), transparent 58%),
        radial-gradient(860px 520px at 92% 0%, rgba(80, 255, 170, .14), transparent 62%),
        radial-gradient(980px 640px at 50% 110%, rgba(255, 140, 80, .10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 50%, var(--bg2));
    }
    a{color:inherit}

    .topbar{
      position:sticky; top:0; z-index:10;
      background: rgba(10, 8, 26, .78);
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(14px);
      padding: 14px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .brand{font-weight: 950; display:flex; align-items:center; gap:10px}
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: linear-gradient(135deg, rgba(255, 90, 120,.95), rgba(80,255,170,.95));
      box-shadow: 0 0 0 5px rgba(255, 90, 120,.14);
    }
    .navBtn{
      text-decoration:none;
      font-weight: 900;
      padding: 9px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.12);
      color: rgba(238,240,255,.92);
    }
    .navBtn.primary{
      background: linear-gradient(135deg, var(--redA), var(--redB));
      border: 1px solid var(--redBorder);
    }
    .wrap{max-width:1100px; margin:0 auto; padding: 18px 16px 70px}
    .hero{
      margin-top: 10px;
      padding: 16px;
      border-radius: var(--r);
      border: 1px solid var(--border);
      background: rgba(255,255,255,.035);
      box-shadow: var(--shadow);
    }
    h1{margin: 4px 0 8px; font-size: 2.1rem}
    p{margin: 6px 0; line-height: 1.6; color: var(--muted)}
    .grid{display:grid; grid-template-columns: 1.15fr .85fr; gap: 16px; margin-top: 16px}
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .card.remix{
      background:
        radial-gradient(900px 420px at 20% 0%, var(--redA), transparent 60%),
        radial-gradient(880px 420px at 90% 12%, rgba(255, 140, 80,.12), transparent 62%),
        rgba(255,255,255,.035);
      border-color: rgba(255, 90, 120,.38);
    }
    .card.stats{
      background:
        radial-gradient(900px 420px at 18% 0%, var(--greenA), transparent 60%),
        radial-gradient(880px 420px at 92% 12%, var(--greenB), transparent 62%),
        rgba(255,255,255,.035);
      border-color: rgba(80,255,170,.34);
    }

    .row{display:flex; flex-wrap:wrap; gap: 10px; align-items:flex-end}
    .field{min-width: 220px; flex:1}
    .field.sm{min-width: 170px; flex: .8}
    .field.xs{min-width: 140px; flex: .55}
    .label{font-size:.9rem; color: var(--muted); margin: 0 0 6px; font-weight: 850}

    select,input[type="text"],input[type="number"],input[type="file"],input[type="range"]{
      width:100%;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.15);
      border-radius: 14px;
      color: rgba(238,240,255,.92);
      padding: 10px 12px;
      outline:none;
    }

    .btn{
      appearance:none;
      border: 1px solid var(--redBorder);
      background: linear-gradient(135deg, var(--redA), var(--redB));
      color: rgba(238,240,255,.96);
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 950;
    }
    .btn.secondary{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.16);
      font-weight: 900;
    }
    .btn.green{
      border-color: var(--greenBorder);
      background: linear-gradient(135deg, var(--greenA), var(--greenB));
    }
    .btn:disabled{opacity:.45; cursor:not-allowed}

    .tiny{font-size:.88rem; color:var(--muted2); font-weight:800}
    .divider{border:0; border-top:1px solid rgba(255,255,255,.10); margin: 12px 0}

    .warn,.ok{
      display:none;
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      white-space: pre-wrap;
      font-weight: 850;
    }
    .warn{border: 1px solid var(--warnBorder); background: var(--warnBg); color: #ffe9da;}
    .ok{border: 1px solid var(--okBorder); background: var(--ok); color: rgba(220,255,235,.96);}

    pre{
      margin: 10px 0 0;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
      color: rgba(238,240,255,.90);
      overflow:auto;
      min-height: 140px;
      font-family: var(--mono);
      font-size: .9rem;
      line-height: 1.45;
    }

    .kv{display:flex; justify-content:space-between; gap: 10px; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,.10)}
    .kv:last-child{border-bottom:none}
    .k{color: var(--muted)}
    .v{font-weight: 950}
  </style>
</head>

<body>
  <div class="topbar">
    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap">
      <div class="brand"><span class="dot"></span>Remix Assistant</div>
      <a class="navBtn" href="https://liamnweir.github.io/liamweirportfolio.github.io/">← Back</a>
    </div>
    <div class="tiny">Upload MIDI → remix → play → download</div>
  </div>

  <div class="wrap">
    <div class="hero">
      <h1>Remix Assistant (MIDI)</h1>
      <p>
        Upload a MIDI and generate a “better” version using simple music theory:
        diatonic reharm, smoother voice-leading, and a lightly improved melody while keeping the same vibe.
      </p>
    </div>

    <div class="grid">
      <section class="card remix">
        <div class="row">
          <div class="field">
            <div class="label">Upload MIDI (.mid)</div>
            <input id="midiFile" type="file" accept=".mid,.midi,audio/midi" />
            <div class="tiny" style="margin-top:6px">Multi-track works. The tool picks a melody track automatically.</div>
          </div>
        </div>

        <div class="divider"></div>

        <div class="row">
          <div class="field sm">
            <div class="label">Style</div>
            <select id="style">
              <option value="lofi" selected>Lofi</option>
              <option value="edm">EDM</option>
              <option value="baroque">Baroque-ish</option>
            </select>
          </div>

          <div class="field sm">
            <div class="label">Remix strength</div>
            <input id="strength" type="range" min="0" max="1" step="0.01" value="0.65" />
            <div class="tiny">Value: <span id="strengthVal">0.65</span></div>
          </div>

          <div class="field sm">
            <div class="label">Key</div>
            <select id="keyOverride">
              <option value="auto" selected>Auto detect</option>
              <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
              <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
              <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
            </select>
          </div>

          <div class="field sm">
            <div class="label">Mode</div>
            <select id="modeOverride">
              <option value="major" selected>Major</option>
              <option value="minor">Minor</option>
              <option value="dorian">Dorian</option>
              <option value="mixolydian">Mixolydian</option>
            </select>
          </div>
        </div>

        <div class="divider"></div>

        <div class="row">
          <button class="btn" id="remixBtn" disabled type="button">Create Remix</button>
          <button class="btn secondary" id="playOrigBtn" disabled type="button">Play Original</button>
          <button class="btn secondary" id="playRemixBtn" disabled type="button">Play Remix</button>
          <button class="btn secondary" id="stopBtn" disabled type="button">Stop</button>
          <button class="btn green" id="downloadBtn" disabled type="button">Download Remix MIDI</button>
        </div>

        <div id="warn" class="warn"></div>
        <div id="ok" class="ok"></div>

        <div class="label" style="margin-top:12px">Log</div>
        <pre id="log">(upload a MIDI file)</pre>

        <div class="tiny" style="margin-top:10px">
          Shortcut: <span style="font-family:var(--mono)">Space</span> stop
        </div>
      </section>

      <section class="card stats">
        <div class="kv"><span class="k">Detected file</span><span class="v" id="statFile">—</span></div>
        <div class="kv"><span class="k">Tempo</span><span class="v" id="statBpm">—</span></div>
        <div class="kv"><span class="k">Key / mode</span><span class="v" id="statKey">—</span></div>
        <div class="kv"><span class="k">Melody track</span><span class="v" id="statTrack">—</span></div>
        <div class="kv"><span class="k">Duration</span><span class="v" id="statDur">—</span></div>

        <div class="divider"></div>
        <div class="tiny">
          If remix harmony sounds off: set the Key manually and try Major/Minor.
        </div>
      </section>
    </div>
  </div>

  <script>
    // ============================================================
    // Key fixes + simplification:
    // 1) Stop button now *always* kills ALL sound:
    //    - Transport.stop/cancel
    //    - dispose Part
    //    - releaseAll on polysynths
    //    - triggerRelease on monosynth
    // 2) Remix now truly manipulates:
    //    - melody (scale snapping + small contour-preserving edits)
    //    - chord plan (diatonic triads fitted per bar)
    //    - bass (roots + simple motion)
    //    while keeping timing, length, and general vibe.
    // 3) Shorter code: removed bank + extra UI + extra FX.
    // ============================================================

    const $ = (id) => document.getElementById(id);
    const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

    const PC_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const NOTE_TO_PC = Object.fromEntries(PC_NAMES.map((n,i)=>[n,i]));

    const MODES = {
      major:      [0,2,4,5,7,9,11],
      minor:      [0,2,3,5,7,8,10],
      dorian:     [0,2,3,5,7,9,10],
      mixolydian: [0,2,4,5,7,9,10]
    };

    function midiToNoteName(m){
      const name = PC_NAMES[((m % 12) + 12) % 12];
      const oct = Math.floor(m / 12) - 1;
      return `${name}${oct}`;
    }

    function setWarn(msg){
      const el = $("warn");
      if(!msg){ el.style.display="none"; el.textContent=""; return; }
      el.style.display="block"; el.textContent = msg;
    }
    function setOk(msg){
      const el = $("ok");
      if(!msg){ el.style.display="none"; el.textContent=""; return; }
      el.style.display="block"; el.textContent = msg;
    }
    function logLine(s){
      const el = $("log");
      if (el.textContent === "(upload a MIDI file)") el.textContent = "";
      el.textContent += (el.textContent ? "\n" : "") + s;
      el.scrollTop = el.scrollHeight;
    }
    function syncStrength(){ $("strengthVal").textContent = Number($("strength").value).toFixed(2); }
    $("strength").addEventListener("input", syncStrength);
    syncStrength();

    // ---------------------------
    // MIDI state
    // ---------------------------
    let midiIn = null;
    let midiOut = null;

    let bpm = 120;
    let keyPc = 0;
    let modeName = "major";
    let beatsPerBar = 4;

    let melodyTrackIndex = -1;
    let melodyNotes = [];

    // stats
    const statFile = $("statFile");
    const statBpm = $("statBpm");
    const statKey = $("statKey");
    const statTrack = $("statTrack");
    const statDur = $("statDur");

    function updateReady(){
      $("remixBtn").disabled = !midiIn;
      $("playOrigBtn").disabled = !midiIn;
      $("playRemixBtn").disabled = !midiOut;
      $("downloadBtn").disabled = !midiOut;
    }

    // ---------------------------
    // MIDI analysis helpers
    // ---------------------------
    function getFirstTempo(m){
      try{
        if (m?.header?.tempos?.length){
          const t = m.header.tempos[0];
          if (t && isFinite(t.bpm) && t.bpm > 0) return t.bpm;
        }
      }catch(e){}
      return 120;
    }

    function midiDurationSeconds(m){
      let maxT = 0;
      for (const tr of m.tracks){
        for (const n of (tr.notes || [])){
          maxT = Math.max(maxT, (n.time || 0) + (n.duration || 0));
        }
      }
      return maxT;
    }

    function pickMelodyTrack(m){
      // heuristic: higher average pitch and not extremely dense
      let best = -1, bestScore = -1e9;
      m.tracks.forEach((tr, idx) => {
        const notes = tr.notes || [];
        if (notes.length < 6) return;
        const avg = notes.reduce((a,n)=>a+(n.midi||0),0)/notes.length;
        const dur = notes.reduce((a,n)=>a+(n.duration||0),0) || 0.001;
        const density = notes.length / dur;
        const score = avg - density*25;
        if (score > bestScore){ bestScore = score; best = idx; }
      });
      if (best < 0) best = m.tracks.findIndex(t => (t.notes||[]).length);
      return best;
    }

    // Krumhansl-Schmuckler style (very light) key detection from pitch-class histogram
    const KS_MAJOR = [6.35,2.23,3.48,2.33,4.38,4.09,2.52,5.19,2.39,3.66,2.29,2.88];
    const KS_MINOR = [6.33,2.68,3.52,5.38,2.60,3.53,2.54,4.75,3.98,2.69,3.34,3.17];

    function rotate(arr, k){
      const n = arr.length;
      const out = new Array(n);
      for(let i=0;i<n;i++) out[i] = arr[(i-k+n)%n];
      return out;
    }
    function dot(a,b){ let s=0; for(let i=0;i<a.length;i++) s += a[i]*b[i]; return s; }

    function detectKey(notes){
      const hist = new Array(12).fill(0);
      for (const n of notes){
        const pc = ((n.midi||0)%12+12)%12;
        hist[pc] += clamp(n.duration||0.1, 0.01, 10);
      }
      const sum = hist.reduce((a,b)=>a+b,0) || 1;
      const norm = hist.map(x=>x/sum);

      let best = { score:-1e9, pc:0, mode:"major" };
      for (let pc=0; pc<12; pc++){
        const maj = dot(norm, rotate(KS_MAJOR, pc));
        const min = dot(norm, rotate(KS_MINOR, pc));
        if (maj > best.score) best = { score:maj, pc, mode:"major" };
        if (min > best.score) best = { score:min, pc, mode:"minor" };
      }
      return best;
    }

    function scalePcs(tonicPc, mode){
      const deg = MODES[mode] || MODES.major;
      return deg.map(x => (x + tonicPc) % 12);
    }
    function snapToScale(midi, allowedPcs){
      const pc = ((midi%12)+12)%12;
      if (allowedPcs.includes(pc)) return midi;
      // search nearest within +/-2 semitones
      for (let s=1; s<=2; s++){
        if (allowedPcs.includes((pc+s)%12)) return midi+s;
        if (allowedPcs.includes((pc-s+12)%12)) return midi-s;
      }
      // otherwise keep
      return midi;
    }

    // ---------------------------
    // Remix: keep rhythm, lightly improve melody, rebuild harmony/bass
    // ---------------------------
    function diatonicTriads(tonicPc, mode){
      const sc = scalePcs(tonicPc, mode);
      const chords = [];
      for (let d=0; d<7; d++){
        chords.push({ degree:d+1, pcs:[sc[d], sc[(d+2)%7], sc[(d+4)%7]], rootPc: sc[d] });
      }
      return chords;
    }

    function overlap(a0,a1,b0,b1){
      const lo = Math.max(a0,b0);
      const hi = Math.min(a1,b1);
      return Math.max(0, hi-lo);
    }

    function fitChordForBar(notes, t0, t1, chords){
      // score chords by how much bar-notes belong to chord
      const scores = chords.map(()=>0);
      for (const n of notes){
        const nt0 = n.time||0;
        const nt1 = nt0 + (n.duration||0.1);
        const ov = overlap(t0,t1,nt0,nt1);
        if (ov<=0) continue;
        const pc = ((n.midi||0)%12+12)%12;
        chords.forEach((ch,i)=>{ if (ch.pcs.includes(pc)) scores[i]+=ov; });
      }
      // bias I and V a bit (more "pop sensible")
      chords.forEach((ch,i)=>{
        if (ch.degree===1) scores[i]*=1.10;
        if (ch.degree===5) scores[i]*=1.06;
      });
      let bestI=0, best=-1e9;
      for (let i=0;i<scores.length;i++){ if (scores[i]>best){ best=scores[i]; bestI=i; } }
      return chords[bestI];
    }

    function improveMelody(notes, tonicPc, mode, strength){
      const allowed = scalePcs(tonicPc, mode);
      const out = notes.map(n => ({...n}));

      // Step 1: snap to scale (gentle)
      for (const n of out){
        n.midi = snapToScale(n.midi, allowed);
      }

      // Step 2: small contour edits to reduce "random jumps"
      // - if a note leaps > 7 semitones from previous, pull it closer toward previous (still in scale)
      // - probability controlled by strength
      for (let i=1; i<out.length; i++){
        const prev = out[i-1];
        const cur = out[i];
        const leap = cur.midi - prev.midi;
        if (Math.abs(leap) >= 8 && Math.random() < (0.35 + 0.45*strength)){
          let target = prev.midi + clamp(leap, -5, 5); // keep direction but smaller
          // snap target to scale near same register
          target = snapToScale(target, allowed);
          cur.midi = clamp(target, 36, 96);
        }
      }

      // Step 3: cadence: end on tonic more often
      if (out.length){
        const last = out[out.length-1];
        const lastPc = ((last.midi%12)+12)%12;
        if (lastPc !== tonicPc){
          // move last pitch to nearest tonic in same octave-ish
          const baseOct = Math.floor(last.midi/12);
          let tonicMidi = baseOct*12 + tonicPc;
          if (Math.abs(tonicMidi-last.midi) > 6) tonicMidi += (tonicMidi<last.midi?12:-12);
          last.midi = clamp(tonicMidi, 36, 96);
        }
      }

      return out;
    }

    function chooseVoicing(chordPcs, centerMidi){
      // simple close-position triad around centerMidi
      const voiced = chordPcs.map(pc=>{
        let m = centerMidi + ((pc - (centerMidi%12) + 12)%12);
        while (m > centerMidi+6) m -= 12;
        while (m < centerMidi-6) m += 12;
        return m;
      }).sort((a,b)=>a-b);
      return voiced;
    }

    function buildRemix(m){
      const style = $("style").value;
      const strength = clamp(Number($("strength").value), 0, 1);

      beatsPerBar = 4;
      bpm = getFirstTempo(m);
      const beatSec = 60/Math.max(1,bpm);
      const barSec = beatsPerBar*beatSec;

      const det = detectKey(melodyNotes);
      const keyOverride = $("keyOverride").value;
      modeName = $("modeOverride").value;

      keyPc = (keyOverride==="auto") ? det.pc : NOTE_TO_PC[keyOverride];

      const durSec = midiDurationSeconds(m);
      const bars = Math.max(1, Math.ceil(durSec / barSec));

      // chord plan per bar
      const chords = diatonicTriads(keyPc, modeName);
      const chordPlan = [];
      for (let b=0; b<bars; b++){
        const t0=b*barSec, t1=(b+1)*barSec;
        chordPlan.push({ t0,t1, chord: fitChordForBar(melodyNotes,t0,t1,chords) });
      }
      // force first/last tonic
      const tonic = chords.find(c=>c.degree===1) || chords[0];
      chordPlan[0].chord = tonic;
      chordPlan[chordPlan.length-1].chord = tonic;

      // output midi
      const out = new Midi();
      try{ out.header.fromJSON(m.header.toJSON()); }catch(e){}
      // NOTE: @tonejs/midi tempo sometimes needs setTempo(secondsPerBeat)
      try{ out.header.setTempo(bpm/60); }catch(e){}

      // Melody track (same rhythm, updated pitches)
      const melT = out.addTrack(); melT.name = "Melody";
      const mel = improveMelody(
        melodyNotes.map(n=>({ midi:n.midi, time:n.time, duration:n.duration, velocity:n.velocity ?? 0.85 })),
        keyPc, modeName, strength
      );
      for (const n of mel){
        melT.addNote({
          midi: clamp(Math.round(n.midi), 24, 108),
          time: Math.max(0, n.time),
          duration: Math.max(0.03, n.duration ?? 0.12),
          velocity: clamp(n.velocity ?? 0.85, 0.1, 1.0),
        });
      }

      // Harmony track (bar chords or broken chords depending on style)
      const chT = out.addTrack(); chT.name = "Chords";
      for (const slot of chordPlan){
        const center = (style==="baroque") ? 58 : 60;
        const voiced = chooseVoicing(slot.chord.pcs, center);

        if (style==="edm"){
          // short stabs (beats 1 and 3)
          const stabDur = 0.45*beatSec;
          const times = [slot.t0, slot.t0 + 2*beatSec];
          for (const tt of times){
            for (const m0 of voiced){
              chT.addNote({ midi:m0, time:tt, duration:stabDur, velocity: 0.55 + 0.15*strength });
            }
          }
        } else if (style==="baroque"){
          // simple arpeggio 8ths
          const step = 0.5*beatSec;
          let t = slot.t0;
          let i = 0;
          while (t < slot.t1 - 0.02){
            const m0 = voiced[i % voiced.length];
            chT.addNote({ midi:m0, time:t, duration:step*0.92, velocity: 0.35 + 0.18*strength });
            t += step; i++;
          }
        } else {
          // lofi: sustained chord
          const dur = (slot.t1-slot.t0) * 0.98;
          for (const m0 of voiced){
            chT.addNote({ midi:m0, time:slot.t0, duration:dur, velocity: 0.34 + 0.16*strength });
          }
        }
      }

      // Bass track (roots with slight motion)
      const baT = out.addTrack(); baT.name = "Bass";
      for (let i=0;i<chordPlan.length;i++){
        const slot = chordPlan[i];
        const rootPc = slot.chord.rootPc;
        let rootMidi = 36 + ((rootPc - (36%12) + 12)%12);
        while (rootMidi > 48) rootMidi -= 12;
        rootMidi = clamp(rootMidi, 28, 55);

        if (style==="edm"){
          // 8th pulses
          const step = 0.5*beatSec;
          let t=slot.t0;
          while (t < slot.t1 - 0.02){
            baT.addNote({ midi:rootMidi, time:t, duration:step*0.92, velocity: 0.68 + 0.20*strength });
            t += step;
          }
        } else {
          // 1 + (optional) 3
          const half = 2*beatSec;
          baT.addNote({ midi:rootMidi, time:slot.t0, duration:half*0.98, velocity: 0.55 + 0.14*strength });
          if (strength > 0.25){
            const fifthPc = (rootPc + 7) % 12;
            let fifthMidi = 36 + ((fifthPc - (36%12) + 12)%12);
            while (fifthMidi > 55) fifthMidi -= 12;
            fifthMidi = clamp(fifthMidi, 28, 60);
            baT.addNote({ midi:fifthMidi, time:slot.t0 + half, duration:half*0.85, velocity: 0.50 + 0.10*strength });
          }
        }
      }

      return { out, info: { bpm, key:`${PC_NAMES[keyPc]} ${modeName}`, bars, style, durSec } };
    }

    // ---------------------------
    // Tone.js playback (robust stop)
    // ---------------------------
    let audioReady = false;
    let lead, pad, bassSynth;
    let reverb, limiter, masterGain;
    let part = null;

    async function ensureAudio(){
      if (Tone.context.state !== "running") await Tone.start();
      if (audioReady) return;

      masterGain = new Tone.Gain(0.95).toDestination();
      limiter = new Tone.Limiter(-1).connect(masterGain);
      reverb = new Tone.Reverb({ decay: 2.4, wet: 0.14 }).connect(limiter);

      lead = new Tone.PolySynth(Tone.Synth, {
        volume: -12,
        options: { oscillator:{type:"triangle"}, envelope:{attack:0.01, decay:0.08, sustain:0.20, release:0.6} }
      }).connect(reverb);

      pad = new Tone.PolySynth(Tone.Synth, {
        volume: -16,
        options: { oscillator:{type:"sawtooth"}, envelope:{attack:0.08, decay:0.2, sustain:0.6, release:1.1} }
      }).connect(reverb);

      bassSynth = new Tone.MonoSynth({
        volume: -10,
        oscillator: { type: "sine" },
        envelope: { attack: 0.01, decay: 0.10, sustain: 0.6, release: 0.12 }
      }).connect(limiter);

      audioReady = true;
    }

    function stopAllSound(){
      // Stop scheduled events
      try{
        if (part){ part.stop(); part.dispose(); part = null; }
      }catch(e){}

      try{
        Tone.Transport.stop();
        Tone.Transport.cancel(0);
        Tone.Transport.position = 0;
      }catch(e){}

      // Kill stuck notes (THIS is what fixes "chords forever")
      try{ lead?.releaseAll?.(); }catch(e){}
      try{ pad?.releaseAll?.(); }catch(e){}
      try{ bassSynth?.triggerRelease?.(); }catch(e){}

      $("stopBtn").disabled = true;
    }

    function flatten(m){
      const all = [];
      for (const tr of m.tracks){
        const name = (tr.name||"").toLowerCase();
        for (const n of (tr.notes||[])){
          all.push({
            midi: n.midi,
            time: n.time ?? 0,
            duration: n.duration ?? 0.1,
            velocity: n.velocity ?? 0.8,
            track: name
          });
        }
      }
      all.sort((a,b)=>a.time-b.time);
      return all;
    }

    function synthForTrack(name){
      if (name.includes("bass")) return "bass";
      if (name.includes("chord") || name.includes("pad")) return "pad";
      return "lead";
    }

    function playMidi(m){
      stopAllSound();
      const notes = flatten(m);
      if (!notes.length) return;

      Tone.Transport.stop();
      Tone.Transport.cancel(0);
      Tone.Transport.position = 0;

      const events = notes.map(n => ({
        time: Math.max(0, n.time),
        midi: clamp(Math.round(n.midi), 24, 108),
        dur: Math.max(0.03, n.duration),
        vel: clamp(n.velocity ?? 0.8, 0.1, 1.0),
        synth: synthForTrack(n.track)
      }));

      part = new Tone.Part((time, v) => {
        const nn = midiToNoteName(v.midi);
        if (v.synth === "bass"){
          bassSynth.triggerAttackRelease(nn, v.dur, time, v.vel);
        } else if (v.synth === "pad"){
          pad.triggerAttackRelease(nn, v.dur, time, v.vel);
        } else {
          lead.triggerAttackRelease(nn, v.dur, time, v.vel);
        }
      }, events);

      part.start(0);
      Tone.Transport.start("+0.02");
      $("stopBtn").disabled = false;
    }

    // ---------------------------
    // Load MIDI
    // ---------------------------
    function setStats({fileName, bpm, key, trackName, trackIndex, durSec}){
      statFile.textContent = fileName || "—";
      statBpm.textContent = bpm ? `${Math.round(bpm)} BPM` : "—";
      statKey.textContent = key || "—";
      statTrack.textContent = (trackIndex != null && trackIndex >= 0)
        ? `#${trackIndex+1} (${trackName || "unnamed"})`
        : "—";
      statDur.textContent = (durSec != null) ? `${durSec.toFixed(2)}s` : "—";
    }

    function parseMidiArrayBuffer(buf, fileName){
      $("log").textContent = "";
      setWarn(null); setOk(null);
      midiOut = null;

      midiIn = new Midi(buf);
      bpm = getFirstTempo(midiIn);

      melodyTrackIndex = pickMelodyTrack(midiIn);
      const tr = midiIn.tracks[melodyTrackIndex];
      melodyNotes = (tr?.notes || []).map(n => ({
        midi: n.midi, time: n.time ?? 0, duration: n.duration ?? 0.1, velocity: n.velocity ?? 0.85
      }));

      const dur = midiDurationSeconds(midiIn);
      const det = detectKey(melodyNotes);

      logLine(`Loaded: ${fileName || "MIDI"}`);
      logLine(`Tempo: ~${Math.round(bpm)} BPM`);
      logLine(`Melody track: #${melodyTrackIndex+1} (${tr?.name || "unnamed"})`);
      logLine(`Key guess: ${PC_NAMES[det.pc]} (${det.mode} leaning)`);
      logLine(`Next: Click “Create Remix”.`);

      setStats({
        fileName: fileName || "MIDI",
        bpm,
        key: `${PC_NAMES[det.pc]} (guess)`,
        trackName: tr?.name,
        trackIndex: melodyTrackIndex,
        durSec: dur
      });

      updateReady();
    }

    $("midiFile").addEventListener("change", async () => {
      const f = $("midiFile").files?.[0];
      if(!f){ midiIn=null; midiOut=null; updateReady(); return; }
      try{
        const buf = await f.arrayBuffer();
        parseMidiArrayBuffer(buf, f.name);
      }catch(e){
        console.error(e);
        setWarn("Failed to parse MIDI. Try a different .mid file.");
        midiIn=null; midiOut=null;
        updateReady();
      }
    });

    // ---------------------------
    // Buttons
    // ---------------------------
    $("remixBtn").addEventListener("click", () => {
      setWarn(null); setOk(null);
      if (!midiIn) return;

      stopAllSound();
      logLine("—");
      logLine("Creating remix…");

      try{
        const { out, info } = buildRemix(midiIn);
        midiOut = out;

        logLine(`Style: ${info.style}`);
        logLine(`Key/Mode: ${info.key}`);
        logLine(`Bars: ${info.bars}`);
        logLine("Done. Play or download.");

        statBpm.textContent = `${Math.round(info.bpm)} BPM`;
        statKey.textContent = info.key;

        updateReady();
        setOk("Remix created.");
      }catch(e){
        console.error(e);
        setWarn(e?.message || "Remix failed. Check console.");
        midiOut = null;
        updateReady();
      }
    });

    $("playOrigBtn").addEventListener("click", async () => {
      if (!midiIn) return;
      setWarn(null);
      try{ await ensureAudio(); playMidi(midiIn); }
      catch(e){ console.error(e); setWarn("Audio failed to start. Click play again."); }
    });

    $("playRemixBtn").addEventListener("click", async () => {
      if (!midiOut) return;
      setWarn(null);
      try{ await ensureAudio(); playMidi(midiOut); }
      catch(e){ console.error(e); setWarn("Audio failed to start. Click play again."); }
    });

    $("stopBtn").addEventListener("click", stopAllSound);

    $("downloadBtn").addEventListener("click", () => {
      if (!midiOut) return;
      try{
        const bytes = midiOut.toArray();
        const blob = new Blob([bytes], { type: "audio/midi" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "remix_assistant_output.mid";
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
        setOk("Downloaded remix MIDI.");
      }catch(e){
        console.error(e);
        setWarn("Download failed. Try remixing again.");
      }
    });

    // keyboard: SPACE stop
    window.addEventListener("keydown", (e) => {
      const tag = (document.activeElement?.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea" || tag === "select") return;
      if (e.code === "Space"){ e.preventDefault(); stopAllSound(); }
    });

    // init
    updateReady();
  </script>
</body>
</html>



