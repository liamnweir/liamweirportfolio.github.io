<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Music Generation System | Liam Weir</title>

  <!-- Tone.js -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>

  <style>
    :root{
      --bg0:#07071a;
      --bg1:#0b1634;
      --panel: rgba(255,255,255,0.085);
      --panel2: rgba(255,255,255,0.06);
      --border: rgba(255,255,255,0.14);
      --text:#eef0ff;
      --muted: rgba(238,240,255,0.78);

      --p:#7c5cff;   /* purple */
      --m:#2fe3b4;   /* mint */
      --b:#4cc9ff;   /* blue */
      --o:#ffb86b;   /* orange */
      --r:#ff5ca8;   /* pink */

      --shadow: 0 22px 70px rgba(0,0,0,0.45);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    *{ box-sizing:border-box }
    html,body{ height:100% }

    body{
      margin:0;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto;
      color: var(--text);
      background:
        radial-gradient(900px 600px at 12% 8%, rgba(124,92,255,0.35), transparent 60%),
        radial-gradient(900px 600px at 88% 18%, rgba(47,227,180,0.22), transparent 62%),
        radial-gradient(900px 600px at 60% 92%, rgba(76,201,255,0.18), transparent 65%),
        radial-gradient(800px 560px at 30% 78%, rgba(255,92,168,0.13), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    a{ color:inherit; text-decoration:none }

    /* Top bar */
    .topbar{
      position:fixed; top:0; left:0; width:100%;
      z-index:20;
      padding: 14px 16px;
      display:flex;
      justify-content:flex-start;
      background: rgba(10,12,30,0.68);
      backdrop-filter: blur(14px);
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    .back{
      display:inline-flex;
      align-items:center;
      gap:10px;
      font-weight:900;
      letter-spacing:.2px;
      padding:10px 14px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.16);
      background:
        linear-gradient(135deg, rgba(124,92,255,0.24), rgba(47,227,180,0.14));
      box-shadow: 0 14px 32px rgba(0,0,0,0.25);
    }
    .back:hover{ filter:brightness(1.08) }

    .wrap{ max-width:1160px; margin:0 auto; padding: 92px 16px 64px }

    .hero{
      display:flex;
      flex-wrap:wrap;
      gap:14px;
      align-items:flex-end;
      justify-content:space-between;
      margin-bottom:14px;
    }
    h1{ margin:0 0 8px; font-size:2.35rem; letter-spacing:.2px }
    p{ margin:8px 0; line-height:1.7; color:var(--muted) }

    .pills{ display:flex; flex-wrap:wrap; gap:8px }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      font-size:.86rem;
      color: rgba(238,240,255,0.86);
    }
    .dot{ width:9px; height:9px; border-radius:999px; box-shadow:0 0 0 4px rgba(255,255,255,0.10) }
    .dot.p{ background:rgba(124,92,255,0.95); box-shadow:0 0 0 4px rgba(124,92,255,0.20) }
    .dot.m{ background:rgba(47,227,180,0.95); box-shadow:0 0 0 4px rgba(47,227,180,0.18) }
    .dot.b{ background:rgba(76,201,255,0.95); box-shadow:0 0 0 4px rgba(76,201,255,0.18) }
    .dot.o{ background:rgba(255,184,107,0.95); box-shadow:0 0 0 4px rgba(255,184,107,0.18) }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 16px;
      margin-top: 14px;
    }
    @media (max-width:980px){ .grid{ grid-template-columns:1fr } }

    .card{
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,0.14);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.09), rgba(255,255,255,0.05));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background:
        linear-gradient(135deg, rgba(124,92,255,0.16), rgba(47,227,180,0.10), rgba(76,201,255,0.10));
    }
    .card .bd{ padding: 16px }

    h2{ margin:0; font-size:1.2rem }
    h3{ margin:0 0 8px; font-size:1.05rem }
    .tiny{ font-size:.88rem; color: rgba(238,240,255,0.72) }
    .mono{ font-family: var(--mono) }

    .row{ display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end }
    .field{ min-width: 170px; flex: 1 1 170px }
    .label{ font-size:.9rem; color: rgba(238,240,255,0.82); margin: 0 0 6px }

    select,input[type="text"],input[type="range"]{
      width:100%;
      background: rgba(255,255,255,0.09);
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 14px;
      padding: 10px 12px;
      outline:none;
    }
    select:focus,input:focus{
      border-color: rgba(124,92,255,0.58);
      box-shadow: 0 0 0 4px rgba(124,92,255,0.18);
    }
    input[type="range"]{ padding: 10px 0 }

    .btn{
      appearance:none;
      cursor:pointer;
      user-select:none;
      padding: 10px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      font-weight: 900;
      letter-spacing:.2px;
      transition: transform .18s ease, filter .18s ease;
    }
    .btn:hover{ transform: translateY(-1px); filter: brightness(1.08) }
    .btn:disabled{ opacity:.45; cursor:not-allowed; transform:none }

    .btn.primary{
      border-color: rgba(124,92,255,0.38);
      background: linear-gradient(135deg, rgba(124,92,255,0.30), rgba(76,201,255,0.16));
    }
    .btn.play{
      border-color: rgba(47,227,180,0.34);
      background: linear-gradient(135deg, rgba(47,227,180,0.22), rgba(124,92,255,0.12));
    }
    .btn.warn{
      border-color: rgba(255,184,107,0.32);
      background: linear-gradient(135deg, rgba(255,184,107,0.18), rgba(255,92,168,0.10));
    }

    /* Toggle look */
    .btn.toggleOn{
      border-color: rgba(255,184,107,0.42);
      background: linear-gradient(135deg, rgba(255,184,107,0.22), rgba(47,227,180,0.10));
    }

    .hr{ border:0; border-top: 1px solid rgba(255,255,255,0.10); margin: 14px 0 }

    .alert{
      display:none;
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,184,107,0.36);
      background: rgba(255,184,107,0.12);
      color: rgba(255,245,235,0.95);
    }

    /* Melody chips */
    .chipsWrap{
      margin-top: 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.20);
      padding: 12px;
    }
    .chipsHead{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .chip{
      position:relative;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      min-width: 64px;
      overflow:hidden;
    }
    .chip .n{ font-weight: 900; letter-spacing:.2px; font-size:.92rem }
    .chip .bar{
      position:absolute;
      left:8px;
      right:8px;
      bottom:7px;
      height:4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.10);
      overflow:hidden;
    }
    .chip .bar > i{
      display:block;
      height:100%;
      width:50%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(124,92,255,0.95), rgba(47,227,180,0.95), rgba(76,201,255,0.95));
      opacity:0.95;
    }

    /* Piano roll */
    .canvasWrap{
      margin-top: 12px;
      border-radius: 16px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,0.12);
      background:
        radial-gradient(900px 280px at 15% 30%, rgba(124,92,255,0.16), transparent 60%),
        radial-gradient(900px 280px at 85% 70%, rgba(47,227,180,0.12), transparent 60%),
        rgba(0,0,0,0.22);
    }
    canvas{ display:block; width:100%; height:auto }

    /* Right panel metrics */
    .kv{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    .kv:last-child{ border-bottom:none }

    /* Ratings */
    .stars{ display:flex; gap:6px; align-items:center }
    .star{
      width:36px; height:36px;
      border-radius: 12px;
      display:grid; place-items:center;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      cursor:pointer;
      user-select:none;
      font-size:18px;
      transition: transform .15s ease, filter .15s ease;
    }
    .star:hover{ transform: translateY(-1px); filter:brightness(1.08) }
    .star.on{
      border-color: rgba(255,184,107,0.42);
      background: linear-gradient(135deg, rgba(255,184,107,0.28), rgba(124,92,255,0.14));
    }

    table{ width:100%; border-collapse:collapse; margin-top:10px; font-size:.92rem }
    th,td{ padding:10px; border-bottom:1px solid rgba(255,255,255,0.10); vertical-align:top }
    th{ text-align:left; color: rgba(238,240,255,0.86); font-weight: 900 }
  </style>
</head>

<body>
  <div class="topbar">
    <a class="back" href="https://liamnweir.github.io/liamweirportfolio.github.io/">← Back to Home</a>
  </div>

  <div class="wrap">
    <div class="hero">
      <div>
        <h1>AI Music Generation System</h1>
        <p>
          Generate short symbolic melodies with controls for key/mode, tempo, length, and melodic motion.
          Play results instantly, export MIDI, and collect listening ratings for comparison.
        </p>
      </div>

      <div class="pills">
        <span class="pill"><span class="dot p"></span>Scale + Chords</span>
        <span class="pill"><span class="dot m"></span>Arpeggio Logic</span>
        <span class="pill"><span class="dot b"></span>Motif Repetition</span>
        <span class="pill"><span class="dot o"></span>Listening Ratings</span>
      </div>
    </div>

    <div class="grid">
      <!-- LEFT -->
      <section class="card">
        <div class="hd">
          <h2>Controls</h2>
          <div class="tiny" style="margin-top:6px">Generate → Play (melody + optional chord pad + optional drums) → Rate</div>
        </div>

        <div class="bd">
          <div class="row">
            <div class="field">
              <div class="label">Key</div>
              <select id="key">
                <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
                <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
                <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
              </select>
            </div>

            <div class="field">
              <div class="label">Mode</div>
              <select id="mode">
                <option value="major">Major (Ionian)</option>
                <option value="dorian">Dorian</option>
                <option value="phrygian">Phrygian</option>
                <option value="lydian">Lydian</option>
                <option value="mixolydian">Mixolydian</option>
                <option value="natural_minor">Natural Minor (Aeolian)</option>
                <option value="locrian">Locrian</option>
                <option value="harmonic_minor">Harmonic Minor</option>
                <option value="melodic_minor">Melodic Minor (Asc.)</option>
                <option value="harmonic_major">Harmonic Major</option>
              </select>
            </div>

            <div class="field">
              <div class="label">Section</div>
              <select id="section">
                <option value="verse" selected>Verse</option>
                <option value="chorus">Chorus</option>
              </select>
            </div>

            <div class="field" style="min-width:220px">
              <div class="label">Tempo: <span id="tempoVal">110</span> BPM</div>
              <input id="tempo" type="range" min="70" max="170" value="110" />
              <div class="tiny" style="margin-top:6px" id="tempoHint">Set tempo, then press Play.</div>
            </div>

            <div class="field">
              <div class="label">Length</div>
              <select id="length">
                <option value="8">8 notes</option>
                <option value="16" selected>16 notes</option>
                <option value="24">24 notes</option>
                <option value="32">32 notes</option>
              </select>
            </div>

            <div class="field">
              <div class="label">Instrument</div>
              <select id="inst">
                <option value="piano" selected>Piano-ish</option>
                <option value="strings">Strings lead</option>
                <option value="soft">Soft synth</option>
                <option value="fm">FM lead</option>
                <option value="am">AM lead</option>
                <option value="pluck">Pluck</option>
                <option value="bell">Bell</option>
              </select>
            </div>

            <div class="field" style="min-width:220px">
              <div class="label">Drum track</div>
              <button class="btn" id="drumBtn" type="button" aria-pressed="false">Drums: Off</button>
              <div class="tiny" style="margin-top:6px">Simple kick/snare/hat pattern (toggles on playback)</div>
            </div>

            <div class="field" style="min-width:220px">
              <div class="label">Chord pad</div>
              <button class="btn toggleOn" id="chordBtn" type="button" aria-pressed="true">Chords: On</button>
              <div class="tiny" style="margin-top:6px">Background chords (toggles on playback)</div>
            </div>
          </div>

          <div class="row" style="margin-top:12px">
            <button class="btn primary" id="genBtn">Generate</button>
            <button class="btn play" id="playBtn" disabled>Play</button>
            <button class="btn warn" id="stopBtn" disabled>Stop</button>
            <button class="btn" id="midiBtn" disabled>Export MIDI</button>
          </div>

          <div id="warn" class="alert"></div>

          <div class="chipsWrap" aria-label="Generated melody preview">
            <div class="chipsHead">
              <div>
                <div class="label" style="margin:0">Melody preview</div>
                <div class="tiny" id="melodyMeta">—</div>
              </div>
              <div class="tiny">Bars = relative duration</div>
            </div>
            <div class="chips" id="chips">
              <div class="tiny">Click Generate to create a melody.</div>
            </div>
          </div>

          <div class="canvasWrap" aria-label="Piano roll">
            <canvas id="roll"></canvas>
          </div>
          <div class="tiny" id="rollInfo" style="margin-top:8px">—</div>

          <div class="hr"></div>

          <h3>Listening Ratings</h3>
          <p class="tiny">Rate the current melody. Ratings are stored locally and exportable as CSV.</p>

          <div class="row" style="align-items:center">
            <div>
              <div class="label">Stars</div>
              <div class="stars" id="stars">
                <div class="star" data-s="1">★</div><div class="star" data-s="2">★</div><div class="star" data-s="3">★</div>
                <div class="star" data-s="4">★</div><div class="star" data-s="5">★</div>
              </div>
            </div>

            <div style="flex:1;min-width:260px">
              <div class="label">Optional comment</div>
              <input id="comment" type="text" placeholder="e.g., 'Good contour, cadence feels strong'" />
            </div>

            <div class="row" style="align-items:flex-end">
              <button class="btn primary" id="saveBtn" disabled>Save</button>
              <button class="btn" id="csvBtn">Export CSV</button>
              <button class="btn" id="clearBtn">Clear</button>
            </div>
          </div>

          <table>
            <thead>
              <tr><th style="width:120px">Stars</th><th>Condition</th><th style="width:140px">Notes</th></tr>
            </thead>
            <tbody id="ratingsBody">
              <tr><td colspan="3" class="tiny">No ratings yet.</td></tr>
            </tbody>
          </table>

          <p class="tiny">
            Shortcuts: <span class="mono">Space</span> play/stop • <span class="mono">G</span> generate • <span class="mono">M</span> export MIDI
          </p>
        </div>
      </section>

      <!-- RIGHT -->
      <aside class="card">
        <div class="hd">
          <h2>Metrics + Results</h2>
          <div class="tiny" style="margin-top:6px">Metrics update per melody; plots update from saved ratings.</div>
        </div>

        <div class="bd">
          <h3>Harmony (current)</h3>
          <div class="kv"><span>Progression</span><strong id="progText">—</strong></div>
          <div class="kv"><span>Cadence</span><strong id="cadText">—</strong></div>

          <div class="hr"></div>

          <h3>Structure Metrics (current)</h3>
          <div class="kv"><span>Repetition</span><strong id="m_rep">—</strong></div>
          <div class="kv"><span>Stepwise motion</span><strong id="m_step">—</strong></div>
          <div class="kv"><span>Range (semitones)</span><strong id="m_range">—</strong></div>
          <div class="kv"><span>Tonal stability</span><strong id="m_tonal">—</strong></div>

          <div class="hr"></div>

          <h3>Ratings Summary (this device)</h3>
          <div class="canvasWrap" style="margin-top:10px">
            <canvas id="plot1"></canvas>
          </div>
          <div class="tiny" style="margin-top:6px">Rating distribution (counts)</div>

          <div class="canvasWrap" style="margin-top:12px">
            <canvas id="plot2"></canvas>
          </div>
          <div class="tiny" style="margin-top:6px">Average rating by mode</div>

          <div class="canvasWrap" style="margin-top:12px">
            <canvas id="plot3"></canvas>
          </div>
          <div class="tiny" style="margin-top:6px">Average rating by tempo bucket</div>
        </div>
      </aside>
    </div>
  </div>

  <script>
    // -------------------------
    // Helpers
    // -------------------------
    const $ = (id) => document.getElementById(id);
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const choice = (pairs) => {
      const sum = pairs.reduce((a,p)=>a+p.w,0);
      let r = Math.random()*sum;
      for(const p of pairs){ r -= p.w; if(r<=0) return p.item; }
      return pairs[pairs.length-1].item;
    };
    const nowISO = () => new Date().toISOString();

    // Convert durBeats (quarter-note beats) to Transport durations
    function durBeatsToTransport(d){
      const eps = 1e-6;
      if(Math.abs(d - 0.25) < eps) return "16n";
      if(Math.abs(d - 0.5)  < eps) return "8n";
      if(Math.abs(d - 1.0)  < eps) return "4n";
      if(Math.abs(d - 2.0)  < eps) return "2n";
      if(Math.abs(d - 4.0)  < eps) return "1m"; // 4 beats
      return "8n";
    }

    // IMPORTANT: schedule event START TIMES in ticks so BPM actually changes playback speed.
    function beatsToTicks(beats){
      const ppq = Tone.Transport.PPQ || 192; // default is 192
      return Math.round(Number(beats) * ppq);
    }
    function ticksTime(ticks){
      return `${Math.max(0, Math.round(ticks))}i`; // "i" = ticks in Tone.js
    }

    // -------------------------
    // Theory
    // -------------------------
    const NOTE = {"C":0,"C#":1,"D":2,"D#":3,"E":4,"F":5,"F#":6,"G":7,"G#":8,"A":9,"A#":10,"B":11};
    const MODES = {
      major:          [0,2,4,5,7,9,11],
      dorian:         [0,2,3,5,7,9,10],
      phrygian:       [0,1,3,5,7,8,10],
      lydian:         [0,2,4,6,7,9,11],
      mixolydian:     [0,2,4,5,7,9,10],
      natural_minor:  [0,2,3,5,7,8,10],
      locrian:        [0,1,3,5,6,8,10],
      harmonic_minor: [0,2,3,5,7,8,11],
      melodic_minor:  [0,2,3,5,7,9,11],
      harmonic_major: [0,2,4,5,7,8,11],
    };
    const NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const ROMAN = ["I","II","III","IV","V","VI","VII"];

    function midiToName(m){
      const name = NAMES[m % 12];
      const oct = Math.floor(m/12) - 1;
      return name + oct;
    }

    function scalePCs(root, modeKey){
      return MODES[modeKey].map(x => (x + root) % 12);
    }

    function triadForDegree(root, modeKey, degree){
      const pcs = scalePCs(root, modeKey);
      const i = (degree-1) % 7;
      const pc1 = pcs[i];
      const pc3 = pcs[(i+2)%7];
      const pc5 = pcs[(i+4)%7];
      return [pc1, pc3, pc5];
    }

    function chordProgression(modeKey){
      const majorLike = (modeKey === "major" || modeKey === "mixolydian" || modeKey === "lydian" || modeKey === "harmonic_major");
      const minors = [
        [1,6,3,7],
        [1,4,7,3],
        [1,5,6,7],
        [1,7,6,7],
      ];
      const majors = [
        [1,5,6,4],
        [1,4,5,1],
        [6,4,1,5],
        [1,6,4,5],
      ];
      return pick(majorLike ? majors : minors);
    }

    function formatProg(prog){ return prog.map(d => ROMAN[d-1]).join(" – "); }

    // -------------------------
    // Elements
    // -------------------------
    const keyEl = $("key"), modeEl = $("mode"), sectionEl = $("section");
    const tempoEl = $("tempo"), tempoVal = $("tempoVal");
    const tempoHint = $("tempoHint");
    const lenEl = $("length"), instEl = $("inst");
    const drumBtn = $("drumBtn");
    const chordBtn = $("chordBtn");

    const genBtn = $("genBtn"), playBtn = $("playBtn"), stopBtn = $("stopBtn"), midiBtn = $("midiBtn");
    const warnEl = $("warn");

    const roll = $("roll"), rollInfo = $("rollInfo");
    const chipsEl = $("chips");
    const melodyMeta = $("melodyMeta");

    const mRep = $("m_rep"), mStep = $("m_step"), mRange = $("m_range"), mTonal = $("m_tonal");
    const progText = $("progText");
    const cadText = $("cadText");

    const starsWrap = $("stars"), commentEl = $("comment"), saveBtn = $("saveBtn"), csvBtn = $("csvBtn"), clearBtn = $("clearBtn"), ratingsBody = $("ratingsBody");
    const plot1 = $("plot1"), plot2 = $("plot2"), plot3 = $("plot3");

    // -------------------------
    // Tempo gating (ONLY editable when stopped)
    // -------------------------
    function setTempoUIEnabled(enabled){
      tempoEl.disabled = !enabled;
      tempoEl.setAttribute("aria-disabled", String(!enabled));
      tempoHint.textContent = enabled
        ? "Set tempo, then press Play."
        : "Stop the track to change tempo.";
    }

    function applyTempo(bpm){
      const v = Number(bpm);
      if(!Number.isFinite(v)) return;
      Tone.Transport.bpm.value = v; // apply immediately
    }

    // Update display while dragging; apply only when NOT playing.
    tempoEl.addEventListener("input", () => {
      tempoVal.textContent = tempoEl.value;
      if(Tone.Transport.state !== "started"){
        applyTempo(tempoEl.value);
      }
    });

    // -------------------------
    // State
    // -------------------------
    let phrase = null;
    let currentProg = null;
    let currentChordEvents = null;
    let currentCadence = "—";
    let currentStars = 0;
    let currentTotalBeats = 0;

    let drumsOn = false;
    let chordsOn = true;

    function renderToggleBtn(btn, on, onText, offText){
      btn.textContent = on ? onText : offText;
      btn.setAttribute("aria-pressed", String(on));
      btn.classList.toggle("toggleOn", on);
    }
    function renderDrumBtn(){ renderToggleBtn(drumBtn, drumsOn, "Drums: On", "Drums: Off"); }
    function renderChordBtn(){ renderToggleBtn(chordBtn, chordsOn, "Chords: On", "Chords: Off"); }

    drumBtn.addEventListener("click", () => { drumsOn = !drumsOn; renderDrumBtn(); });
    chordBtn.addEventListener("click", () => { chordsOn = !chordsOn; renderChordBtn(); });

    // -------------------------
    // Alerts
    // -------------------------
    function setWarn(msg){
      if(!msg){ warnEl.style.display="none"; warnEl.textContent=""; return; }
      warnEl.style.display="block";
      warnEl.textContent = msg;
    }

    // -------------------------
    // Audio (shared bus + stable levels)
    // -------------------------
    let masterReady = false;
    let bus, limiter, comp, verb;
    let melodyGain, chordGain, drumGain;

    let melodySynth = null;
    let chordSynth = null;

    let melodyPart = null;
    let chordPart = null;

    let kick = null, snare = null, hat = null;
    let drumPart = null;

    function ensureMaster(){
      if(masterReady) return;

      bus = new Tone.Gain(1.0);
      comp = new Tone.Compressor({ threshold:-22, ratio:2.2, attack:0.01, release:0.25 });
      limiter = new Tone.Limiter(-1);
      verb = new Tone.Reverb({decay:2.4, preDelay:0.01, wet:0.22});

      bus.connect(comp);
      comp.connect(limiter);
      limiter.toDestination();

      verb.connect(bus);

      melodyGain = new Tone.Gain(0.95).connect(bus);
      chordGain  = new Tone.Gain(0.55).connect(bus);
      drumGain   = new Tone.Gain(0.55).connect(bus);

      masterReady = true;
    }

    function buildMelodySynth(kind){
      ensureMaster();
      if(melodySynth){ try{melodySynth.dispose();}catch(e){} melodySynth=null; }

      if(kind === "fm"){
        melodySynth = new Tone.PolySynth(Tone.FMSynth, {
          volume: -14,
          harmonicity: 1.5,
          modulationIndex: 10,
          envelope: { attack: 0.01, decay: 0.18, sustain: 0.20, release: 0.7 },
          modulationEnvelope: { attack: 0.01, decay: 0.20, sustain: 0.0, release: 0.2 }
        });
      } else if(kind === "am"){
        melodySynth = new Tone.PolySynth(Tone.AMSynth, {
          volume: -14,
          harmonicity: 1.0,
          envelope: { attack: 0.01, decay: 0.20, sustain: 0.22, release: 0.8 },
          modulationEnvelope: { attack: 0.01, decay: 0.18, sustain: 0.0, release: 0.25 }
        });
      } else if(kind === "pluck"){
        melodySynth = new Tone.PolySynth(Tone.PluckSynth, {
          volume: -14,
          attackNoise: 1.0,
          dampening: 4200,
          resonance: 0.82
        });
      } else if(kind === "bell"){
        melodySynth = new Tone.PolySynth(Tone.FMSynth, {
          volume: -16,
          harmonicity: 2.0,
          modulationIndex: 18,
          envelope: { attack: 0.005, decay: 0.8, sustain: 0.0, release: 1.2 },
          modulationEnvelope: { attack: 0.005, decay: 0.6, sustain: 0.0, release: 0.8 }
        });
      } else {
        const base = {
          volume: -10,
          oscillator: { type: "triangle" },
          envelope: { attack: 0.008, decay: 0.22, sustain: 0.28, release: 0.9 }
        };

        if(kind === "strings"){
          base.oscillator.type = "sawtooth";
          base.envelope = { attack: 0.06, decay: 0.20, sustain: 0.55, release: 1.2 };
          base.volume = -12;
        } else if (kind === "soft"){
          base.oscillator.type = "sine";
          base.envelope = { attack: 0.01, decay: 0.10, sustain: 0.22, release: 0.5 };
          base.volume = -12;
        }

        melodySynth = new Tone.PolySynth(Tone.Synth, base);
      }

      melodySynth.connect(melodyGain);
      melodySynth.connect(verb);
      return melodySynth;
    }

    function buildChordSynth(){
      ensureMaster();
      if(chordSynth){ try{chordSynth.dispose();}catch(e){} chordSynth=null; }

      chordSynth = new Tone.PolySynth(Tone.Synth, {
        volume: -16,
        oscillator: { type: "sawtooth" },
        envelope: { attack: 0.25, decay: 0.55, sustain: 0.65, release: 1.8 }
      });

      chordSynth.connect(chordGain);
      chordSynth.connect(verb);
      return chordSynth;
    }

    function buildDrums(){
      ensureMaster();
      if(kick){ try{kick.dispose();}catch(e){} kick=null; }
      if(snare){ try{snare.dispose();}catch(e){} snare=null; }
      if(hat){ try{hat.dispose();}catch(e){} hat=null; }

      kick = new Tone.MembraneSynth({
        pitchDecay: 0.03,
        octaves: 8,
        oscillator: { type: "sine" },
        envelope: { attack: 0.001, decay: 0.18, sustain: 0.0, release: 0.1 }
      }).connect(drumGain);

      snare = new Tone.NoiseSynth({
        noise: { type: "white" },
        envelope: { attack: 0.001, decay: 0.14, sustain: 0.0, release: 0.05 }
      }).connect(drumGain);

      hat = new Tone.MetalSynth({
        frequency: 250,
        envelope: { attack: 0.001, decay: 0.08, release: 0.01 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 3000,
        octaves: 1.2
      }).connect(drumGain);

      kick.connect(verb);
      snare.connect(verb);
      hat.connect(verb);
    }

    async function ensureAudio(){
      if(Tone.context.state !== "running") await Tone.start();
      buildMelodySynth(instEl.value);
      buildChordSynth();
      buildDrums();
    }

    function stopPlayback(){
      if(melodyPart){ try{melodyPart.stop(); melodyPart.dispose();}catch(e){} melodyPart=null; }
      if(chordPart){ try{chordPart.stop(); chordPart.dispose();}catch(e){} chordPart=null; }
      if(drumPart){ try{drumPart.stop(); drumPart.dispose();}catch(e){} drumPart=null; }

      Tone.Transport.stop();
      Tone.Transport.cancel();
      Tone.Transport.position = 0;

      // Re-enable tempo editing once stopped
      setTempoUIEnabled(true);
      applyTempo(tempoEl.value);

      playBtn.disabled = !phrase;
      stopBtn.disabled = true;
    }

    // -------------------------
    // Drums scheduled in TICKS (so BPM changes actually change spacing)
    // -------------------------
    function scheduleDrums(totalBeats){
      if(!drumsOn) return;

      if(drumPart){ try{drumPart.stop(); drumPart.dispose();}catch(e){} drumPart=null; }

      const stepBeats = 0.25; // 16th note in beats
      const stepsTotal = Math.max(1, Math.round(totalBeats / stepBeats));
      const events = [];

      for(let s=0; s<stepsTotal; s++){
        const tBeats = s * stepBeats;
        const stepInBar = s % 16;

        if(stepInBar === 0 || stepInBar === 8){
          events.push({ time: ticksTime(beatsToTicks(tBeats)), type:"kick", vel: 0.95 });
        }
        if(stepInBar === 4 || stepInBar === 12){
          events.push({ time: ticksTime(beatsToTicks(tBeats)), type:"snare", vel: 0.75 });
        }
        if(stepInBar % 2 === 0){
          const vel = (stepInBar === 0 || stepInBar === 8) ? 0.35 : 0.28;
          events.push({ time: ticksTime(beatsToTicks(tBeats)), type:"hat", vel });
        }
        if(stepInBar === 10 && Math.random() < 0.35){
          events.push({ time: ticksTime(beatsToTicks(tBeats)), type:"kick", vel: 0.65 });
        }
      }

      drumPart = new Tone.Part((time, v) => {
        if(v.type === "kick"){
          kick.triggerAttackRelease("C1", "8n", time, v.vel);
        } else if(v.type === "snare"){
          snare.triggerAttackRelease("16n", time, v.vel);
        } else if(v.type === "hat"){
          hat.triggerAttackRelease("32n", time, v.vel);
        }
      }, events);

      drumPart.start(0);
    }

    // -------------------------
    // Playback scheduling (ALL event times in TICKS)
    // -------------------------
    function sumBeats(notes){ return notes.reduce((a,n)=>a+n.durBeats, 0); }

    function schedulePlayback(notes){
      Tone.Transport.stop();
      Tone.Transport.cancel();
      Tone.Transport.position = 0;

      // Lock tempo during playback: disable slider and apply BPM once
      setTempoUIEnabled(false);
      applyTempo(tempoEl.value);

      const totalBeats = currentTotalBeats || sumBeats(notes);
      const totalTicks = beatsToTicks(totalBeats);

      // Melody events (tick-based start times so tempo changes actually change spacing)
      let tBeats = 0;
      const melEvents = notes.map(n => {
        const evt = {
          time: ticksTime(beatsToTicks(tBeats)),
          midi: clamp(n.midi, 24, 108),
          durBeats: Number(n.durBeats)
        };
        tBeats += evt.durBeats;
        return evt;
      });

      melodyPart = new Tone.Part((time, v) => {
        const name = midiToName(v.midi);
        const durStr = durBeatsToTransport(v.durBeats);
        melodySynth.triggerAttackRelease(name, durStr, time, 0.92);
      }, melEvents);
      melodyPart.start(0);

      // Chords each bar (optional) — also tick-based times
      if(chordsOn){
        const chordEvents = (currentChordEvents || []).map(ev => ({
          time: ticksTime(beatsToTicks(ev.time)), // ev.time is in beats
          midis: ev.midis
        }));

        chordPart = new Tone.Part((time, v) => {
          const freqs = v.midis.map(m => Tone.Frequency(clamp(m, 24, 108), "midi"));
          chordSynth.triggerAttackRelease(freqs, "1m", time, 0.55);
        }, chordEvents);
        chordPart.start(0);
      } else {
        chordPart = null;
      }

      // Drums (optional)
      scheduleDrums(totalBeats);

      // Auto-stop at end so tempo unlocks even if user doesn't press Stop
      Tone.Transport.scheduleOnce(() => {
        stopPlayback();
      }, ticksTime(totalTicks));

      Tone.Transport.start("+0.02");
    }

    // -------------------------
    // Rhythm generation (fits bars) + supports 16th/8th/quarter/half/whole
    // -------------------------
    function targetBeatsForLength(len){
      const bars = Math.max(1, Math.round(len / 8));
      return bars * 4;
    }

    function makeDurations(count, targetBeats, section){
      const versePalette = [
        {d:0.25, w:3.0},
        {d:0.5,  w:6.2},
        {d:1.0,  w:3.2},
        {d:2.0,  w:1.1},
        {d:4.0,  w:0.35},
      ];
      const chorusPalette = [
        {d:0.25, w:2.0},
        {d:0.5,  w:4.2},
        {d:1.0,  w:4.2},
        {d:2.0,  w:1.6},
        {d:4.0,  w:0.55},
      ];
      const palette = (section === "chorus") ? chorusPalette : versePalette;

      const durs = [];
      let remaining = targetBeats;

      for(let i=0;i<count;i++){
        const notesLeft = count - i;

        const minEach = 0.25;
        const minNeeded = (notesLeft - 1) * minEach;
        const maxThis = Math.max(minEach, remaining - minNeeded);

        if(i === count - 1){
          durs.push(remaining);
          remaining = 0;
          break;
        }

        const phrasePos = i / Math.max(1, count-1);
        const longBoost = (phrasePos > 0.66) ? 1.25 : 1.0;

        const candidates = palette
          .filter(p => p.d <= maxThis + 1e-9)
          .map(p => ({item: p.d, w: p.w * (p.d >= 1.0 ? longBoost : 1.0)}));

        let d = choice(candidates);

        const after = remaining - d;
        const canFinish = after >= (notesLeft-1)*minEach - 1e-9;
        if(!canFinish){
          const sorted = candidates.map(c=>c.item).sort((a,b)=>b-a);
          d = sorted.find(x => (remaining - x) >= (notesLeft-1)*minEach - 1e-9) ?? minEach;
        }

        durs.push(d);
        remaining -= d;
      }

      if(Math.abs(remaining) > 1e-6 && durs.length){
        durs[durs.length-1] += remaining;
      }

      if(durs.length >= 2){
        const last = durs[durs.length-1];
        if(last < 1.0 && durs[durs.length-2] > 0.25){
          const take = Math.min(0.25, durs[durs.length-2] - 0.25);
          durs[durs.length-2] -= take;
          durs[durs.length-1] += take;
        }
      }

      return durs;
    }

    // -------------------------
    // Musical melody generation (theory-based) WITHOUT bias
    // -------------------------
    function nearestMidiForPC(pc, aroundMidi){
      const base = aroundMidi - (aroundMidi % 12) + pc;
      const opts = [base-12, base, base+12];
      return opts.reduce((best, m) => (Math.abs(m-aroundMidi) < Math.abs(best-aroundMidi) ? m : best), opts[0]);
    }

    function inScale(midi, scaleSet){ return scaleSet.has(((midi % 12) + 12) % 12); }

    function chordTonesMidi(triadPCs, aroundMidi){
      const out = [];
      for(const pc of triadPCs){
        const m = nearestMidiForPC(pc, aroundMidi);
        out.push(m-12, m, m+12);
      }
      return Array.from(new Set(out)).sort((a,b)=>a-b);
    }

    function scaleTonesMidi(scalePCsArr, centerMidi){
      const out = [];
      for(const pc of scalePCsArr){
        const m = nearestMidiForPC(pc, centerMidi);
        out.push(m-12, m, m+12);
      }
      return Array.from(new Set(out)).sort((a,b)=>a-b);
    }

    function degreeAtTime(prog, tBeats, totalBeats){
      const bars = Math.max(1, Math.round(totalBeats / 4));
      const bar = clamp(Math.floor(tBeats / 4), 0, bars-1);
      const idx = clamp(bar, 0, prog.length-1);
      return prog[idx];
    }

    function isStrongBeat(tBeats){
      const posInBar = ((tBeats % 4) + 4) % 4;
      const eps = 1e-6;
      const onBeat = Math.abs(posInBar - Math.round(posInBar)) < eps;
      if(!onBeat) return false;
      return (posInBar === 0 || posInBar === 2);
    }

    function boundedRange(m, section){
      if(section === "chorus") return clamp(m, 52, 88);
      return clamp(m, 48, 82);
    }

    function makeMotif(rootMidi, scaleMidis, chordMidis, section){
      const motif = [];
      let cur = rootMidi;
      for(let i=0;i<4;i++){
        const strong = (i === 0 || i === 2);
        const pool = strong ? chordMidis : scaleMidis;

        const near = pool.filter(m => Math.abs(m-cur) <= 5);
        const candidates = (near.length ? near : pool).map(m => {
          const dist = Math.abs(m-cur);
          return {item:m, w: 1 / (1 + dist)};
        });

        let next = choice(candidates);
        next = boundedRange(next, section);

        motif.push(next);
        cur = next;
      }
      return motif;
    }

    function varyMotif(motif, scaleSet, section){
      const out = motif.slice();
      const changes = (Math.random() < 0.6) ? 1 : 2;

      for(let c=0;c<changes;c++){
        const idx = 1 + Math.floor(Math.random() * (out.length-2));
        const cur = out[idx];
        const opts = [cur-2, cur-1, cur+1, cur+2].filter(m => inScale(m, scaleSet));
        if(opts.length) out[idx] = boundedRange(pick(opts), section);
      }
      return out;
    }

    function generateMelodyTheory({key, mode, length, section}){
      const rootPC = NOTE[key];
      const pcsArr = scalePCs(rootPC, mode);
      const scaleSet = new Set(pcsArr);

      const prog = chordProgression(mode);
      const totalBeats = targetBeatsForLength(length);

      const durs = makeDurations(length, totalBeats, section);

      const tonicMidi = 60 + rootPC;
      const startMidi = boundedRange(tonicMidi, section);
      const endMidi   = boundedRange(tonicMidi, section);

      const scaleMidis = scaleTonesMidi(pcsArr, tonicMidi);

      const firstDeg = prog[0];
      const firstTriad = triadForDegree(rootPC, mode, firstDeg);
      const firstChordMidis = chordTonesMidi(firstTriad, tonicMidi);

      const motifA = makeMotif(startMidi, scaleMidis, firstChordMidis, section);
      const motifAprime = varyMotif(motifA, scaleSet, section);

      const notes = [];
      let cur = startMidi;
      let t = 0;
      let lastInterval = 0;

      function chordAtTime(tBeats){
        const deg = degreeAtTime(prog, tBeats, totalBeats);
        const triad = triadForDegree(rootPC, mode, deg);
        return chordTonesMidi(triad, cur);
      }

      // NO stepwise-bias: just musical weighting
      function chooseNext(chordMidis, strong){
        const scalePool = scaleMidis;
        const chordPool = chordMidis;

        let basePool = strong ? chordPool : scalePool;

        const maxJump = (section === "chorus") ? (strong ? 9 : 7) : (strong ? 7 : 5);
        let pool = basePool.filter(m => Math.abs(m-cur) <= maxJump);
        if(!pool.length) pool = basePool;

        const weighted = pool.map(m => {
          const interval = m - cur;
          const dist = Math.abs(interval);
          let w = 1 / (1 + dist);

          if(Math.abs(lastInterval) >= 6){
            const opposite = (lastInterval > 0 && interval < 0) || (lastInterval < 0 && interval > 0);
            if(opposite && dist <= 2) w *= 2.2;
          }

          const center = (section === "chorus") ? (tonicMidi + 7) : (tonicMidi + 3);
          const drift = Math.abs(m - center);
          w *= 1 / (1 + drift/10);

          if(strong && chordPool.includes(m)) w *= 2.2;
          return {item: boundedRange(m, section), w};
        });

        const next = choice(weighted);
        lastInterval = next - cur;
        return next;
      }

      notes.push({midi: boundedRange(nearestMidiForPC(rootPC, startMidi), section), durBeats: durs[0]});
      t += durs[0];
      cur = notes[0].midi;

      for(let i=1;i<length-2;i++){
        const strong = isStrongBeat(t);
        const chordMidis = chordAtTime(t);

        let injected = null;
        const third = length / 3;

        if(length >= 16){
          if(i < third && i-1 < motifA.length) injected = motifA[i-1];
          else if(i >= third && i < 2*third){
            const j = i - Math.floor(third);
            if(j < motifAprime.length) injected = motifAprime[j];
          }
        } else if(length >= 8){
          if(i-1 < motifA.length) injected = motifA[i-1];
        }

        let next;
        if(injected !== null){
          next = inScale(injected, scaleSet) ? injected : nearestMidiForPC(((injected%12)+12)%12, cur);
          next = boundedRange(next, section);

          if(strong && !chordMidis.includes(next)){
            next = chordMidis.reduce((best, m) => (Math.abs(m-cur) < Math.abs(best-cur) ? m : best), chordMidis[0]);
            next = boundedRange(next, section);
          }
          lastInterval = next - cur;
        } else {
          next = chooseNext(chordMidis, strong);
        }

        notes.push({midi: next, durBeats: durs[i]});
        t += durs[i];
        cur = next;
      }

      const domPC = (rootPC + 7) % 12;
      const leadPC = (rootPC + 11) % 12;
      const useLead = (mode === "major" || mode === "harmonic_minor" || mode === "harmonic_major") && scaleSet.has(leadPC);

      const penultPC = useLead ? leadPC : domPC;
      let penult = nearestMidiForPC(penultPC, cur);
      penult = boundedRange(penult, section);

      notes.push({midi: penult, durBeats: durs[length-2]});
      notes.push({midi: boundedRange(nearestMidiForPC(rootPC, endMidi), section), durBeats: durs[length-1]});

      return { notes, prog, cadence: useLead ? "Leading tone → Tonic" : "Dominant → Tonic", totalBeats };
    }

    function buildChordEvents({key, mode, prog, totalBeats}){
      const rootPC = NOTE[key];
      const bars = Math.max(1, Math.round(totalBeats / 4));
      const events = [];

      for(let b=0;b<bars;b++){
        const deg = prog[Math.min(b, prog.length-1)];
        const triadPCs = triadForDegree(rootPC, mode, deg);

        const center = 48 + rootPC;
        const midis = triadPCs
          .map(pc => nearestMidiForPC(pc, center))
          .map(m => m <= 36 ? m+12 : m)
          .sort((a,b)=>a-b);

        events.push({ time: b*4, midis }); // time in beats (converted to ticks later)
      }
      return events;
    }

    // -------------------------
    // Metrics
    // -------------------------
    function metrics(notes, key, mode){
      const midis = notes.map(n=>n.midi);

      const uniq = new Set(midis);
      const repetition = 1 - (uniq.size / midis.length);

      let steps=0;
      for(let i=1;i<midis.length;i++){
        if(Math.abs(midis[i]-midis[i-1])<=2) steps++;
      }
      const stepwise = steps / Math.max(1, midis.length-1);

      const range = Math.max(...midis) - Math.min(...midis);

      const root = NOTE[key];
      const minorish = (mode.includes("minor") || mode==="dorian" || mode==="phrygian" || mode==="locrian");
      const triad = minorish ? [0,3,7] : [0,4,7];
      const triadPC = new Set(triad.map(x => (x + root) % 12));
      const tonal = midis.filter(m => triadPC.has(m%12)).length / midis.length;

      return {repetition, stepwise, range, tonal};
    }

    function renderMetrics(m){
      mRep.textContent   = m.repetition.toFixed(2);
      mStep.textContent  = m.stepwise.toFixed(2);
      mRange.textContent = String(m.range);
      mTonal.textContent = m.tonal.toFixed(2);
    }

    // -------------------------
    // Melody chips
    // -------------------------
    function renderChips(notes){
      if(!notes || !notes.length){
        chipsEl.innerHTML = `<div class="tiny">Click Generate to create a melody.</div>`;
        melodyMeta.textContent = "—";
        return;
      }
      const total = sumBeats(notes);
      const maxDur = Math.max(...notes.map(n=>n.durBeats));
      melodyMeta.textContent = `${notes.length} notes • ${total.toFixed(2)} beats • starts/ends on tonic • ${formatProg(currentProg || [])}`;

      chipsEl.innerHTML = notes.map(n => {
        const w = Math.max(12, Math.round((n.durBeats / maxDur) * 100));
        const name = midiToName(n.midi);
        return `
          <div class="chip" title="${name}">
            <div class="n">${name}</div>
            <div class="bar"><i style="width:${w}%"></i></div>
          </div>
        `;
      }).join("");
    }

    // -------------------------
    // Piano roll (colorful)
    // -------------------------
    function fitCanvas(canvas, cssH){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = Math.max(320, Math.floor(canvas.getBoundingClientRect().width));
      canvas.width = Math.floor(w*dpr);
      canvas.height = Math.floor(cssH*dpr);
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, w, h: cssH};
    }
    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function isBlackKey(pc){ return [1,3,6,8,10].includes(pc); }

    function pitchFill(midi){
      const t = (midi - 36) / (96 - 36);
      const hue = 265 - (t * 220);
      return `hsla(${hue}, 92%, 60%, 0.62)`;
    }
    function pitchStroke(midi){
      const t = (midi - 36) / (96 - 36);
      const hue = 265 - (t * 220);
      return `hsla(${hue}, 95%, 70%, 0.95)`;
    }

    function drawRoll(notes){
      const cssH = 270;
      const {ctx, w, h} = fitCanvas(roll, cssH);

      const bg = ctx.createLinearGradient(0,0,w,h);
      bg.addColorStop(0, "rgba(8,10,26,0.86)");
      bg.addColorStop(1, "rgba(7,8,18,0.62)");
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,w,h);

      if(!notes || !notes.length){
        rollInfo.textContent = "—";
        return;
      }

      const midis = notes.map(n=>n.midi);
      const lo = Math.min(...midis), hi = Math.max(...midis);
      const pad = 3;
      const minM = Math.max(24, lo-pad), maxM = Math.min(108, hi+pad);
      const rows = Math.max(1, maxM - minM + 1);

      const left = 14, right = 12, top = 12, bottom = 12;
      const usableW = w - left - right;
      const usableH = h - top - bottom;
      const rowH = usableH / rows;

      const total = sumBeats(notes);
      const beatW = usableW / Math.max(0.001, total);

      for(let r=0;r<rows;r++){
        const midi = maxM - r;
        const pc = midi % 12;
        const y = top + r*rowH;
        const black = isBlackKey(pc);
        ctx.fillStyle = black ? "rgba(255,255,255,0.040)" : "rgba(255,255,255,0.022)";
        ctx.fillRect(left, y, usableW, rowH);
      }

      const quarters = Math.ceil(total / 0.25);
      for(let b=0;b<=quarters;b++){
        const x = left + (b*0.25)*beatW;
        const isBar = (b % 16 === 0);
        ctx.strokeStyle = isBar ? "rgba(76,201,255,0.16)" : "rgba(255,255,255,0.08)";
        ctx.lineWidth = isBar ? 1.6 : 1;
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, h-bottom);
        ctx.stroke();
      }

      let t=0;
      for(const n of notes){
        const x = left + t*beatW;
        const nw = Math.max(3, n.durBeats*beatW);
        const y = top + (maxM - n.midi)*rowH + 1;
        const nh = Math.max(3, rowH-2);

        ctx.fillStyle = "rgba(0,0,0,0.24)";
        roundRect(ctx, x+3, y+2, Math.max(2, nw-2), nh, 10);
        ctx.fill();

        ctx.fillStyle = pitchFill(n.midi);
        ctx.strokeStyle = pitchStroke(n.midi);
        ctx.lineWidth = 1.2;
        roundRect(ctx, x+1, y, Math.max(2, nw-2), nh, 10);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "rgba(255,255,255,0.10)";
        roundRect(ctx, x+2, y+1, Math.max(2, nw-4), Math.max(2, nh*0.35), 10);
        ctx.fill();

        t += n.durBeats;
      }

      rollInfo.textContent = `Range: ${hi-lo} semitones • Total: ${total.toFixed(2)} beats`;
    }

    window.addEventListener("resize", () => drawRoll(phrase));

    // -------------------------
    // MIDI export (melody only)
    // -------------------------
    function exportMIDI(notes, bpm){
      const PPQ = 480;
      const u16 = n => [(n>>8)&255, n&255];
      const u32 = n => [(n>>24)&255, (n>>16)&255, (n>>8)&255, n&255];
      const str = s => Array.from(s).map(c=>c.charCodeAt(0));
      function vlq(n){
        let bytes = [n & 0x7F];
        while((n >>= 7)) bytes.unshift((n & 0x7F) | 0x80);
        return bytes;
      }

      const header = [...str("MThd"), ...u32(6), ...u16(0), ...u16(1), ...u16(PPQ)];
      const ev = [];

      const mpqn = Math.round(60000000 / Math.max(1, bpm));
      ev.push(...vlq(0), 0xFF, 0x51, 0x03, (mpqn>>16)&255, (mpqn>>8)&255, mpqn&255);
      ev.push(...vlq(0), 0xC0, 0x00);

      for(const n of notes){
        const durTicks = Math.max(1, Math.round(n.durBeats * PPQ));
        ev.push(...vlq(0),       0x90, clamp(n.midi,0,127), 100);
        ev.push(...vlq(durTicks),0x80, clamp(n.midi,0,127), 0);
      }
      ev.push(...vlq(0), 0xFF, 0x2F, 0x00);

      const track = [...str("MTrk"), ...u32(ev.length), ...ev];
      const bytes = new Uint8Array([...header, ...track]);
      const blob = new Blob([bytes], {type:"audio/midi"});
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "generated_phrase.mid";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    midiBtn.addEventListener("click", () => {
      if(!phrase) return;
      exportMIDI(phrase, Number(tempoEl.value));
    });

    // -------------------------
    // Ratings + plots
    // -------------------------
    const RATINGS_KEY = "liam_ai_music_ratings_v6_no_bias";

    function loadRatings(){
      try{ return JSON.parse(localStorage.getItem(RATINGS_KEY) || "[]"); }
      catch(e){ return []; }
    }
    function saveRatings(list){
      localStorage.setItem(RATINGS_KEY, JSON.stringify(list));
    }

    function setStars(n){
      currentStars = n;
      starsWrap.querySelectorAll(".star").forEach(el => {
        const s = Number(el.dataset.s);
        el.classList.toggle("on", s <= n);
      });
      saveBtn.disabled = !(phrase && currentStars>0);
    }

    starsWrap.addEventListener("click", (e) => {
      const el = e.target.closest(".star");
      if(!el) return;
      setStars(Number(el.dataset.s));
    });

    function renderTable(){
      const list = loadRatings();
      if(!list.length){
        ratingsBody.innerHTML = `<tr><td colspan="3" class="tiny">No ratings yet.</td></tr>`;
        return;
      }
      const view = list.slice(-10).reverse();
      ratingsBody.innerHTML = view.map(r => `
        <tr>
          <td>${"★".repeat(r.stars)}${"☆".repeat(5-r.stars)}</td>
          <td>${r.key} ${r.mode.replaceAll("_"," ")} • ${r.section} • tempo ${r.bpm} • chords ${r.chordsOn?"on":"off"} • drums ${r.drumsOn?"on":"off"} • ${r.prog}</td>
          <td>${r.length}</td>
        </tr>
      `).join("");
    }

    function downloadText(filename, text, type){
      const blob = new Blob([text], {type: type || "text/plain"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    saveBtn.addEventListener("click", () => {
      if(!phrase || !currentStars) return;

      const key = keyEl.value;
      const mode = modeEl.value;
      const section = sectionEl.value;
      const bpm = Number(tempoEl.value);
      const length = Number(lenEl.value);

      const m = metrics(phrase, key, mode);
      const entry = {
        ts: nowISO(),
        stars: currentStars,
        comment: (commentEl.value || "").trim(),
        key, mode, section, bpm, length,
        drumsOn, chordsOn,
        prog: formatProg(currentProg || []),
        cadence: currentCadence,
        metrics: m
      };

      const list = loadRatings();
      list.push(entry);
      saveRatings(list);

      commentEl.value = "";
      setStars(0);
      renderTable();
      renderPlots();
      setWarn(null);
    });

    csvBtn.addEventListener("click", () => {
      const list = loadRatings();
      if(!list.length){ setWarn("No ratings to export yet."); return; }

      const header = ["ts","stars","comment","key","mode","section","bpm","length","drumsOn","chordsOn","progression","cadence","repetition","stepwise","range","tonal"];
      const esc = (s) => `"${String(s ?? "").replaceAll('"','""')}"`;

      const rows = list.map(r => ([
        esc(r.ts),
        r.stars,
        esc(r.comment),
        esc(r.key),
        esc(r.mode),
        esc(r.section),
        r.bpm,
        r.length,
        r.drumsOn ? 1 : 0,
        r.chordsOn ? 1 : 0,
        esc(r.prog),
        esc(r.cadence),
        (r.metrics?.repetition ?? "").toFixed?.(4) ?? "",
        (r.metrics?.stepwise ?? "").toFixed?.(4) ?? "",
        r.metrics?.range ?? "",
        (r.metrics?.tonal ?? "").toFixed?.(4) ?? ""
      ].join(",")));

      downloadText("ai_music_ratings.csv", [header.join(","), ...rows].join("\n"), "text/csv");
      setWarn(null);
    });

    clearBtn.addEventListener("click", () => {
      localStorage.removeItem(RATINGS_KEY);
      renderTable();
      renderPlots();
      setWarn(null);
    });

    function barChart(canvas, labels, values, title){
      const cssH = 200;
      const {ctx, w, h} = fitCanvas(canvas, cssH);
      ctx.clearRect(0,0,w,h);

      const bg = ctx.createLinearGradient(0,0,w,h);
      bg.addColorStop(0, "rgba(10,12,28,0.82)");
      bg.addColorStop(1, "rgba(7,8,18,0.62)");
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,w,h);

      const padL = 44, padR = 12, padT = 28, padB = 36;
      const innerW = w - padL - padR;
      const innerH = h - padT - padB;

      ctx.fillStyle = "rgba(238,240,255,0.88)";
      ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText(title || "", 12, 18);

      const maxV = Math.max(1e-9, ...values);
      const n = values.length;
      const gap = 8;
      const barW = Math.max(6, (innerW - gap*(n-1)) / n);

      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, padT + innerH);
      ctx.lineTo(padL + innerW, padT + innerH);
      ctx.stroke();

      ctx.fillStyle = "rgba(238,240,255,0.65)";
      ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
      for(let t=0;t<=2;t++){
        const yVal = (maxV * t/2);
        const y = padT + innerH - (innerH * t/2);
        ctx.fillText(String(yVal.toFixed(1)).replace(".0",""), 8, y+4);
        ctx.strokeStyle = "rgba(255,255,255,0.06)";
        ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(padL+innerW, y); ctx.stroke();
      }

      for(let i=0;i<n;i++){
        const v = values[i];
        const bh = (v/maxV)*innerH;
        const x = padL + i*(barW+gap);
        const y = padT + innerH - bh;

        const gg = ctx.createLinearGradient(0, y, 0, y+bh);
        gg.addColorStop(0, "rgba(124,92,255,0.68)");
        gg.addColorStop(1, "rgba(47,227,180,0.32)");

        ctx.fillStyle = gg;
        ctx.strokeStyle = "rgba(76,201,255,0.55)";
        ctx.lineWidth = 1.1;
        roundRect(ctx, x, y, barW, bh, 10);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = "rgba(238,240,255,0.72)";
        ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
        const lab = labels[i];
        const tx = x + barW/2;
        ctx.save();
        ctx.translate(tx, padT + innerH + 14);
        ctx.rotate(-0.35);
        ctx.textAlign = "center";
        ctx.fillText(lab, 0, 0);
        ctx.restore();
      }
    }

    function renderPlots(){
      const list = loadRatings();

      const counts = [1,2,3,4,5].map(s => list.filter(r => r.stars===s).length);
      barChart(plot1, ["1","2","3","4","5"], counts, "Rating distribution (counts)");

      const byMode = {};
      for(const r of list){
        const k = r.mode;
        if(!byMode[k]) byMode[k] = {sum:0, n:0};
        byMode[k].sum += r.stars; byMode[k].n += 1;
      }
      const modeItems = Object.entries(byMode)
        .map(([k,v]) => ({k, avg: v.sum / Math.max(1,v.n), n:v.n}))
        .sort((a,b)=> (b.n - a.n) || (b.avg - a.avg))
        .slice(0, 6);

      barChart(
        plot2,
        modeItems.length ? modeItems.map(x => x.k.replaceAll("_"," ")) : ["—"],
        modeItems.length ? modeItems.map(x => Number(x.avg.toFixed(2))) : [0],
        "Average rating by mode"
      );

      const buckets = {};
      const bucketOf = (bpm) => {
        const v = Number(bpm);
        if(!Number.isFinite(v)) return "—";
        const step = 20;
        const lo = Math.floor(v/step)*step;
        return `${lo}-${lo+step-1}`;
      };
      for(const r of list){
        const k = bucketOf(r.bpm);
        if(!buckets[k]) buckets[k] = {sum:0,n:0};
        buckets[k].sum += r.stars; buckets[k].n += 1;
      }
      const keys = Object.keys(buckets).sort((a,b)=>{
        const la = Number(a.split("-")[0]||0);
        const lb = Number(b.split("-")[0]||0);
        return la-lb;
      }).slice(0, 6);
      const vals = keys.map(k => buckets[k] ? (buckets[k].sum / buckets[k].n) : 0);

      barChart(plot3, keys.length?keys:["—"], keys.length?vals:[0], "Average rating by tempo bucket");
    }

    // -------------------------
    // Main actions
    // -------------------------
    genBtn.addEventListener("click", () => {
      stopPlayback();
      setWarn(null);

      const key = keyEl.value;
      const mode = modeEl.value;
      const section = sectionEl.value;
      const length = Number(lenEl.value);

      try{
        const out = generateMelodyTheory({key, mode, length, section});
        phrase = out.notes;
        currentProg = out.prog;
        currentCadence = out.cadence;
        currentTotalBeats = out.totalBeats;

        currentChordEvents = buildChordEvents({key, mode, prog: currentProg, totalBeats: out.totalBeats});

        progText.textContent = formatProg(currentProg);
        cadText.textContent = currentCadence;

        renderChips(phrase);

        const m = metrics(phrase, key, mode);
        renderMetrics(m);

        drawRoll(phrase);

        playBtn.disabled = false;
        midiBtn.disabled = false;
        saveBtn.disabled = !(currentStars>0);
      }catch(e){
        phrase = null;
        currentProg = null;
        currentChordEvents = null;
        currentTotalBeats = 0;
        progText.textContent = "—";
        cadText.textContent = "—";
        renderChips(null);
        drawRoll(null);
        renderMetrics({repetition:0,stepwise:0,range:0,tonal:0});
        playBtn.disabled = true; stopBtn.disabled = true; midiBtn.disabled = true; saveBtn.disabled = true;
        setWarn(e?.message || "Generation failed.");
      }
    });

    playBtn.addEventListener("click", async () => {
      if(!phrase) return;
      setWarn(null);
      try{
        await ensureAudio();

        // Reset transport (also re-enables tempo), then immediately lock + schedule with current BPM
        stopPlayback();
        applyTempo(tempoEl.value);

        schedulePlayback(phrase);
        playBtn.disabled = true;
        stopBtn.disabled = false;
      }catch(e){
        setTempoUIEnabled(true);
        setWarn("Audio blocked by browser. Click Play again to enable sound.");
      }
    });

    stopBtn.addEventListener("click", stopPlayback);

    window.addEventListener("keydown", (e) => {
      const tag = (document.activeElement?.tagName || "").toLowerCase();
      if(tag === "input" || tag === "textarea" || tag === "select") return;

      if(e.code === "Space"){
        e.preventDefault();
        if(!stopBtn.disabled) stopPlayback();
        else if(!playBtn.disabled) playBtn.click();
      }else if(e.key.toLowerCase() === "g"){
        genBtn.click();
      }else if(e.key.toLowerCase() === "m"){
        if(!midiBtn.disabled) midiBtn.click();
      }
    });

    // Init
    renderTable();
    renderPlots();
    renderChips(null);
    drawRoll(null);
    tempoVal.textContent = tempoEl.value;
    renderDrumBtn();
    renderChordBtn();

    setTempoUIEnabled(true);
    applyTempo(tempoEl.value);
  </script>
</body>
</html>













