<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Music Generation System | Liam Weir</title>

  <!-- Tone.js (audio playback) -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>

  <style>
    :root{
      --bg:#0a0a12; --panel:rgba(255,255,255,.05); --border:rgba(255,255,255,.10);
      --text:#eef0ff; --muted:rgba(238,240,255,.78);
      --accent:rgba(120,140,255,.20); --accentBorder:rgba(120,140,255,.40);
      --warnBg:rgba(255,180,120,.10); --warnBorder:rgba(255,180,120,.30);
      --shadow:0 24px 50px rgba(0,0,0,.35);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto;background:var(--bg);color:var(--text)}
    a{color:inherit}
    .topbar{
      position:fixed; top:0; left:0; width:100%;
      background:rgba(10,10,25,.85); backdrop-filter:blur(12px);
      border-bottom:1px solid var(--border); z-index:10;
      padding:14px 16px; display:flex; justify-content:flex-start;
    }
    .back{
      text-decoration:none; font-weight:800; letter-spacing:.2px;
      padding:10px 14px; border-radius:999px;
      background:var(--accent); border:1px solid var(--accentBorder);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:86px 16px 60px}
    h1{margin:0 0 6px;font-size:2.2rem}
    h2{margin:0 0 10px;font-size:1.25rem}
    h3{margin:0 0 8px;font-size:1.05rem}
    p{margin:8px 0;line-height:1.6;color:var(--muted)}
    .grid{display:grid;grid-template-columns:1.15fr .85fr;gap:16px;margin-top:16px}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}
    .panel{
      background:var(--panel); border:1px solid var(--border);
      border-radius:var(--radius); box-shadow:var(--shadow);
      padding:16px;
    }
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:flex-end}
    .field{min-width:170px}
    .label{font-size:.9rem;color:var(--muted);margin:0 0 6px}
    select,input[type="text"],input[type="number"],input[type="range"]{
      width:100%;
      background:rgba(255,255,255,.06); color:var(--text);
      border:1px solid rgba(255,255,255,.14); border-radius:14px;
      padding:10px 12px; outline:none;
    }
    input[type="range"]{padding:10px 0}
    .btn{
      appearance:none; border:1px solid var(--accentBorder);
      background:var(--accent); color:var(--text);
      padding:10px 14px; border-radius:14px; cursor:pointer;
      font-weight:800; letter-spacing:.2px;
    }
    .btn:disabled{opacity:.45;cursor:not-allowed}
    .btn.secondary{background:rgba(255,255,255,.06);border-color:rgba(255,255,255,.16)}
    .pill{display:inline-block;margin:6px 6px 0 0;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04);font-size:.86rem;color:var(--muted)}
    .warn{display:none;margin-top:12px;padding:10px 12px;border-radius:14px;border:1px solid var(--warnBorder);background:var(--warnBg);color:#ffe9da}
    pre{
      margin:10px 0 0; padding:12px; border-radius:14px;
      background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.10);
      overflow:auto; min-height:160px; color:rgba(238,240,255,.92); font-family:var(--mono); font-size:.92rem;
    }
    .kv{display:flex;justify-content:space-between;gap:10px;padding:8px 0;border-bottom:1px solid rgba(255,255,255,.10)}
    .kv:last-child{border-bottom:none}
    .mono{font-family:var(--mono)}
    .tiny{font-size:.88rem;color:rgba(238,240,255,.70)}
    .hr{border:0;border-top:1px solid rgba(255,255,255,.10);margin:14px 0}
    .canvasWrap{
      margin-top:12px;border-radius:14px; overflow:hidden;
      border:1px solid rgba(255,255,255,.10); background:rgba(0,0,0,.25)
    }
    canvas{display:block;width:100%;height:auto}
    .stars{display:flex;gap:6px;align-items:center}
    .star{
      width:34px;height:34px;border-radius:12px;display:grid;place-items:center;
      border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.04);
      cursor:pointer; user-select:none; font-size:18px
    }
    .star.on{background:var(--accent);border-color:var(--accentBorder)}
    table{width:100%;border-collapse:collapse;margin-top:10px;font-size:.92rem}
    th,td{padding:10px;border-bottom:1px solid rgba(255,255,255,.10);vertical-align:top}
    th{text-align:left;color:rgba(238,240,255,.82);font-weight:900}
    code{font-family:var(--mono);font-size:.92em}
    details summary{cursor:pointer;color:rgba(238,240,255,.9);font-weight:800}
    .list{margin:8px 0 0;padding-left:18px;color:var(--muted);line-height:1.65}
  </style>
</head>

<body>
  <div class="topbar">
    <a class="back" href="https://liamnweir.github.io/liamweirportfolio.github.io/">← Back to Home</a>
  </div>

  <div class="wrap">
    <h1>AI Music Generation System</h1>
    <p>
      A clean, single-file demo that generates short symbolic melodies (notes + durations), plays them back, visualizes a piano roll,
      computes simple structure metrics, and collects listener ratings (stored locally + exportable CSV).
    </p>
    <div>
      <span class="pill">AI</span><span class="pill">Music</span><span class="pill">HCI / Evaluation</span><span class="pill">Tone.js</span><span class="pill">GitHub Pages</span>
    </div>

    <div class="grid">
      <!-- LEFT: DEMO -->
      <section class="panel">
        <h2>Interactive Demo</h2>

        <div class="row">
          <div class="field">
            <div class="label">Key</div>
            <select id="key">
              <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
              <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
              <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
            </select>
          </div>

          <div class="field">
            <div class="label">Mode</div>
            <select id="mode">
              <option value="major">Major (Ionian)</option>
              <option value="natural_minor">Natural Minor (Aeolian)</option>
              <option value="harmonic_minor">Harmonic Minor</option>
              <option value="dorian">Dorian</option>
              <option value="mixolydian">Mixolydian</option>
            </select>
          </div>

          <div class="field" style="min-width:220px">
            <div class="label">Tempo: <span id="tempoVal">110</span> BPM</div>
            <input id="tempo" type="range" min="70" max="170" value="110" />
          </div>

          <div class="field" style="min-width:220px">
            <div class="label">Stepwise Bias: <span id="biasVal">0.75</span></div>
            <input id="bias" type="range" min="0" max="1" step="0.01" value="0.75" />
          </div>

          <div class="field">
            <div class="label">Length</div>
            <select id="length">
              <option value="8">8 notes</option>
              <option value="16" selected>16 notes</option>
              <option value="24">24 notes</option>
              <option value="32">32 notes</option>
            </select>
          </div>

          <div class="field">
            <div class="label">Instrument</div>
            <select id="inst">
              <option value="piano" selected>Piano-ish</option>
              <option value="strings">Strings pad</option>
              <option value="soft">Soft synth</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <button class="btn" id="genBtn">Generate</button>
          <button class="btn" id="playBtn" disabled>Play</button>
          <button class="btn secondary" id="stopBtn" disabled>Stop</button>
          <button class="btn secondary" id="copyBtn" disabled>Copy Notes</button>
          <button class="btn secondary" id="midiBtn" disabled>Export MIDI</button>
        </div>

        <div id="warn" class="warn"></div>

        <div class="label" style="margin-top:12px">Generated phrase (note : beats)</div>
        <pre id="out">(click Generate)</pre>

        <div class="canvasWrap" aria-label="Piano roll">
          <canvas id="roll"></canvas>
        </div>
        <div class="tiny" id="rollInfo" style="margin-top:8px">—</div>

        <div class="hr"></div>

        <h3>Listening Study (User Ratings)</h3>
        <p>Rate the current phrase. Ratings are stored locally on this device and can be exported as CSV.</p>

        <div class="row" style="align-items:center">
          <div>
            <div class="label">Stars</div>
            <div class="stars" id="stars">
              <div class="star" data-s="1">★</div><div class="star" data-s="2">★</div><div class="star" data-s="3">★</div>
              <div class="star" data-s="4">★</div><div class="star" data-s="5">★</div>
            </div>
          </div>

          <div style="flex:1;min-width:260px">
            <div class="label">Optional comment</div>
            <input id="comment" type="text" placeholder="e.g., 'Nice cadence, rhythm feels jumpy'" />
          </div>

          <div class="row" style="align-items:flex-end">
            <button class="btn" id="saveBtn" disabled>Save Rating</button>
            <button class="btn secondary" id="csvBtn">Export CSV</button>
            <button class="btn secondary" id="clearBtn">Clear</button>
          </div>
        </div>

        <table>
          <thead>
            <tr><th style="width:120px">Stars</th><th>Condition</th><th style="width:140px">Notes</th></tr>
          </thead>
          <tbody id="ratingsBody">
            <tr><td colspan="3" class="tiny">No ratings yet.</td></tr>
          </tbody>
        </table>

        <p class="tiny">
          Shortcuts: <span class="mono">Space</span> play/stop • <span class="mono">G</span> generate •
          <span class="mono">C</span> copy • <span class="mono">M</span> export MIDI
        </p>
      </section>

      <!-- RIGHT: METRICS + HIRING MAGNET SECTIONS -->
      <aside class="panel">
        <h2>Writeup (Hiring Magnet)</h2>

        <h3>Problem → Why it matters</h3>
        <p>
          Creators want fast, controllable ways to generate musical ideas without losing musical coherence.
          This project explores simple controllable generation + lightweight evaluation so we can connect model behavior to listener preferences.
        </p>

        <h3>Your contributions</h3>
        <ul class="list">
          <li>Built a browser-based symbolic melody generator with key/mode, tempo, length, and stepwise controls.</li>
          <li>Implemented playback (Tone.js), MIDI export, and a piano-roll visualization for interpretability.</li>
          <li>Designed a listening-study loop (ratings + comments) with exportable data for later analysis.</li>
          <li>Added simple structure metrics to compare “features” vs. what listeners actually like.</li>
        </ul>

        <div class="hr"></div>

        <h3>Architecture diagram</h3>
        <pre class="mono" style="min-height:0">
Browser UI
  ├─ Generator (rule-based baseline) → notes+durations
  ├─ Playback (Tone.js)              → audio
  ├─ Export (MIDI/Clipboard)         → files/text
  └─ Evaluation
       ├─ metrics (repetition/stepwise/range/tonal)
       └─ listener ratings (localStorage → CSV)</pre>

        <div class="hr"></div>

        <h3>Perception / Structure Metrics</h3>
        <p class="tiny">Heuristics you can report now, then validate with your listening data.</p>
        <div class="kv"><span>Repetition</span><strong id="m_rep">—</strong></div>
        <div class="kv"><span>Stepwise motion</span><strong id="m_step">—</strong></div>
        <div class="kv"><span>Range (semitones)</span><strong id="m_range">—</strong></div>
        <div class="kv"><span>Tonal stability</span><strong id="m_tonal">—</strong></div>

        <div class="hr"></div>

        <h3>Evidence (results, not just features)</h3>
        <p class="tiny">
          These plots update from your saved ratings. They’re the start of a real “results” section:
          distribution, condition comparisons, and an interpretation you can write up.
        </p>

        <div class="canvasWrap" style="margin-top:10px">
          <canvas id="plot1"></canvas>
        </div>
        <div class="tiny" style="margin-top:6px">Plot 1: Rating distribution (1–5 stars)</div>

        <div class="canvasWrap" style="margin-top:12px">
          <canvas id="plot2"></canvas>
        </div>
        <div class="tiny" style="margin-top:6px">Plot 2: Average rating by mode (from your data)</div>

        <div class="canvasWrap" style="margin-top:12px">
          <canvas id="plot3"></canvas>
        </div>
        <div class="tiny" style="margin-top:6px">Plot 3: Average rating by stepwise-bias bucket</div>

        <details style="margin-top:10px">
          <summary>Interpretation template (edit after you collect data)</summary>
          <p class="tiny" style="margin-top:8px">
            In our pilot ratings on this device, listeners preferred <strong>(MODE / BIAS RANGE)</strong>.
            Higher stepwise bias tended to <strong>(increase/decrease)</strong> ratings, suggesting that
            singability/connected motion is <strong>(important/not sufficient)</strong> without rhythmic variety.
          </p>
        </details>

        <div class="hr"></div>

        <h3>Demo media (add these to get hired faster)</h3>
        <ul class="list">
          <li>Add a 30–60s screen recording: <code>assets/demo.mp4</code> and link it here.</li>
          <li>Add 3–5 example outputs: <code>assets/example1.mid</code>, <code>example1.wav</code>, etc.</li>
        </ul>
        <p class="tiny">
          Place files in your repo under <code>assets/</code>, then link them:
          <br>
          <span class="mono">• demo video: assets/demo.mp4</span>
          <br>
          <span class="mono">• examples: assets/ex1.mid, assets/ex1.wav ...</span>
        </p>

        <div class="hr"></div>

        <h3>Code & reproducibility</h3>
        <ul class="list">
          <li>Repo: <code>(paste your GitHub repo link here)</code></li>
          <li>Run locally: <code>python -m http.server</code> (or VS Code “Live Server”), open this file.</li>
          <li>Data: export CSV from this page and analyze in Python/R (correlate metrics with ratings).</li>
          <li>Next: replace baseline generator with a Transformer backend and do A/B tests.</li>
        </ul>

        <details style="margin-top:10px">
          <summary>Optional (advanced): ML backend hook</summary>
          <p class="tiny" style="margin-top:8px">
            If you later host a model (e.g., Hugging Face Spaces), add a simple POST endpoint returning:
            <code>{"notes":[{"midi":60,"durBeats":0.5}, ...]}</code>.
            Then you can compare baseline vs. model with the same evaluation UI.
          </p>
        </details>
      </aside>
    </div>
  </div>

  <script>
    // -------------------------
    // Tiny helpers
    // -------------------------
    const $ = (id) => document.getElementById(id);
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const nowISO = () => new Date().toISOString();

    // -------------------------
    // Theory
    // -------------------------
    const NOTE = {"C":0,"C#":1,"D":2,"D#":3,"E":4,"F":5,"F#":6,"G":7,"G#":8,"A":9,"A#":10,"B":11};
    const MODES = {
      major:         [0,2,4,5,7,9,11],
      natural_minor: [0,2,3,5,7,8,10],
      harmonic_minor:[0,2,3,5,7,8,11],
      dorian:        [0,2,3,5,7,9,10],
      mixolydian:    [0,2,4,5,7,9,10],
    };
    const NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    function midiToName(m){
      const name = NAMES[m % 12];
      const oct = Math.floor(m/12) - 1;
      return name + oct;
    }

    // -------------------------
    // Elements
    // -------------------------
    const keyEl = $("key"), modeEl = $("mode"), tempoEl = $("tempo"), tempoVal = $("tempoVal");
    const biasEl = $("bias"), biasVal = $("biasVal"), lenEl = $("length"), instEl = $("inst");
    const genBtn = $("genBtn"), playBtn = $("playBtn"), stopBtn = $("stopBtn"), copyBtn = $("copyBtn"), midiBtn = $("midiBtn");
    const outEl = $("out"), warnEl = $("warn");
    const roll = $("roll"), rollInfo = $("rollInfo");

    const mRep = $("m_rep"), mStep = $("m_step"), mRange = $("m_range"), mTonal = $("m_tonal");

    const starsWrap = $("stars"), commentEl = $("comment"), saveBtn = $("saveBtn"), csvBtn = $("csvBtn"), clearBtn = $("clearBtn"), ratingsBody = $("ratingsBody");

    const plot1 = $("plot1"), plot2 = $("plot2"), plot3 = $("plot3");

    tempoEl.addEventListener("input", () => tempoVal.textContent = tempoEl.value);
    biasEl.addEventListener("input", () => biasVal.textContent = Number(biasEl.value).toFixed(2));

    // -------------------------
    // State
    // -------------------------
    let phrase = null; // [{midi, durBeats}]
    let currentStars = 0;

    // -------------------------
    // Audio (simple + stable)
    // -------------------------
    let synth = null, part = null;
    let masterReady = false;
    let masterGain, reverb, limiter;

    function setWarn(msg){
      if(!msg){ warnEl.style.display="none"; warnEl.textContent=""; return; }
      warnEl.style.display="block"; warnEl.textContent = msg;
    }

    function ensureMaster(){
      if(masterReady) return;
      masterGain = new Tone.Gain(0.90);
      reverb = new Tone.Reverb({decay:2.2, preDelay:0.01, wet:0.18});
      limiter = new Tone.Limiter(-1);
      // synth -> masterGain -> limiter -> destination, with reverb send
      masterGain.connect(limiter);
      limiter.toDestination();
      masterReady = true;
    }

    function buildSynth(kind){
      ensureMaster();
      if(synth){ try{synth.dispose();}catch(e){} synth=null; }

      const base = {
        volume: -8,
        oscillator: { type: "triangle" },
        envelope: { attack: 0.01, decay: 0.25, sustain: 0.25, release: 0.9 }
      };

      if(kind === "strings"){
        base.oscillator.type = "sawtooth";
        base.envelope = { attack: 0.12, decay: 0.18, sustain: 0.75, release: 1.3 };
        base.volume = -10;
      } else if (kind === "soft"){
        base.oscillator.type = "sine";
        base.envelope = { attack: 0.01, decay: 0.08, sustain: 0.20, release: 0.35 };
        base.volume = -10;
      }

      synth = new Tone.PolySynth(Tone.Synth, base);
      // dry
      synth.connect(masterGain);
      // reverb send (no delay, so long notes won't "repeat")
      synth.connect(reverb);
      reverb.connect(masterGain);

      return synth;
    }

    async function ensureAudio(){
      if(Tone.context.state !== "running") await Tone.start();
      buildSynth(instEl.value);
    }

    function stopPlayback(){
      if(part){ try{part.stop(); part.dispose();}catch(e){} part=null; }
      Tone.Transport.stop();
      Tone.Transport.cancel();
      Tone.Transport.position = 0;
      playBtn.disabled = !phrase;
      stopBtn.disabled = true;
    }

    function schedulePlayback(notes){
      Tone.Transport.stop();
      Tone.Transport.cancel();
      Tone.Transport.position = 0;
      Tone.Transport.bpm.value = Number(tempoEl.value);

      let t = 0;
      const events = notes.map(n => {
        const evt = { time: t, midi: clamp(n.midi, 24, 108), dur: Number(n.durBeats) };
        t += evt.dur;
        return evt;
      });

      part = new Tone.Part((time, v) => {
        const name = midiToName(v.midi);
        const durSec = Tone.Time(v.dur).toSeconds();
        synth.triggerAttackRelease(name, durSec, time, 0.9);
      }, events);

      part.start(0);
      Tone.Transport.start("+0.02");
    }

    // -------------------------
    // Generator (simple baseline)
    // -------------------------
    function allowedNotes(root, modeKey){
      const pcs = MODES[modeKey].map(x => (x + root));
      const base = 60; // around C4
      const out = [];
      for(let oct=-1; oct<=1; oct++){
        for(const pc of pcs) out.push(base + pc + 12*oct);
      }
      return out.sort((a,b)=>a-b);
    }

    // Simple duration pattern (keeps code small + musical enough)
    // Uses mostly 1/4 and 1/2 with occasional 1/8 and 1.
    function sampleDur(){
      const r = Math.random();
      if(r < 0.12) return 0.125; // 1/8
      if(r < 0.65) return 0.25;  // 1/4
      if(r < 0.92) return 0.5;   // 1/2
      return 1.0;                // 1
    }

    function generate({key, mode, bias, length}){
      const root = NOTE[key];
      const allowed = allowedNotes(root, mode);
      const tonic = 60 + root;

      let cur = tonic;
      const notes = [];

      for(let i=0;i<length;i++){
        // stepwise candidates within 2 semitones
        const near = allowed.filter(n => Math.abs(n - cur) <= 2);
        const pool = (Math.random() < bias && near.length) ? near : allowed;

        // small contour: first half gently rises, second half gently falls
        const target = (i < length/2) ? cur + 2 : cur - 2;
        const weighted = pool
          .map(n => ({n, w: 1 / (1 + Math.abs(n - target))}))
          .sort((a,b)=>b.w-a.w)
          .slice(0, Math.max(6, Math.floor(pool.length*0.35)))
          .map(x=>x.n);

        // cadence: last 2 notes prefer near tonic or dominant
        let finalPool = weighted;
        if(i >= length-2){
          const dom = tonic + 7;
          const cad = allowed.filter(n => Math.min(Math.abs(n-tonic), Math.abs(n-dom)) <= 3);
          if(cad.length) finalPool = cad;
        }

        cur = pick(finalPool);
        const d = (i===length-1) ? 0.5 : sampleDur(); // anchor ending a bit
        notes.push({midi: cur, durBeats: d});
      }

      return notes;
    }

    // -------------------------
    // Metrics
    // -------------------------
    function metrics(notes, key, mode){
      const midis = notes.map(n=>n.midi);

      const uniq = new Set(midis);
      const repetition = 1 - (uniq.size / midis.length);

      let steps=0;
      for(let i=1;i<midis.length;i++){
        if(Math.abs(midis[i]-midis[i-1])<=2) steps++;
      }
      const stepwise = steps / Math.max(1, midis.length-1);

      const range = Math.max(...midis) - Math.min(...midis);

      const root = NOTE[key];
      const minorish = (mode.includes("minor") || mode==="dorian");
      const triad = minorish ? [0,3,7] : [0,4,7];
      const triadPC = new Set(triad.map(x => (x + root) % 12));
      const tonal = midis.filter(m => triadPC.has(m%12)).length / midis.length;

      return {repetition, stepwise, range, tonal};
    }

    function renderPhrase(notes){
      outEl.textContent = notes.map(n => `${midiToName(n.midi)} : ${Number(n.durBeats).toFixed(3)}`).join("\n");
    }

    function renderMetrics(m){
      mRep.textContent   = m.repetition.toFixed(2);
      mStep.textContent  = m.stepwise.toFixed(2);
      mRange.textContent = String(m.range);
      mTonal.textContent = m.tonal.toFixed(2);
    }

    // -------------------------
    // Piano roll (always auto-fit)
    // -------------------------
    function sumBeats(notes){ return notes.reduce((a,n)=>a+n.durBeats, 0); }

    function fitCanvas(canvas, cssH){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = Math.max(320, Math.floor(canvas.getBoundingClientRect().width));
      canvas.width = Math.floor(w*dpr);
      canvas.height = Math.floor(cssH*dpr);
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return {ctx, w, h: cssH};
    }

    function drawRoll(notes){
      const cssH = 240;
      const {ctx, w, h} = fitCanvas(roll, cssH);

      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = "rgba(5,5,12,0.85)";
      ctx.fillRect(0,0,w,h);

      if(!notes || !notes.length){
        rollInfo.textContent = "—";
        return;
      }

      const midis = notes.map(n=>n.midi);
      const lo = Math.min(...midis), hi = Math.max(...midis);
      const pad = 2;
      const minM = Math.max(24, lo-pad), maxM = Math.min(108, hi+pad);
      const rows = Math.max(1, maxM - minM + 1);

      const left = 10, right = 10, top = 10, bottom = 10;
      const usableW = w - left - right;
      const usableH = h - top - bottom;
      const rowH = usableH / rows;

      const total = sumBeats(notes);
      const beatW = usableW / Math.max(0.001, total);

      // beat grid (quarter beats)
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      for(let b=0;b<=Math.ceil(total/0.25);b++){
        const x = left + (b*0.25)*beatW;
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, h-bottom);
        ctx.stroke();
      }

      // note rows shading
      for(let r=0;r<rows;r++){
        const y = top + r*rowH;
        ctx.fillStyle = (r%2===0) ? "rgba(255,255,255,0.03)" : "rgba(255,255,255,0.015)";
        ctx.fillRect(left, y, usableW, rowH);
      }

      // notes
      let t=0;
      for(const n of notes){
        const x = left + t*beatW;
        const nw = Math.max(2, n.durBeats*beatW);
        const y = top + (maxM - n.midi)*rowH + 1;
        const nh = Math.max(2, rowH-2);

        ctx.fillStyle = "rgba(120,140,255,0.42)";
        ctx.strokeStyle = "rgba(120,140,255,0.80)";
        ctx.lineWidth = 1;
        roundRect(ctx, x+1, y, Math.max(2, nw-2), nh, 6);
        ctx.fill();
        ctx.stroke();

        t += n.durBeats;
      }

      rollInfo.textContent = `Range: ${hi-lo} semitones • Total: ${total.toFixed(2)} beats`;
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    window.addEventListener("resize", () => drawRoll(phrase));

    // -------------------------
    // Copy + MIDI export
    // -------------------------
    function phraseText(notes){
      return notes.map(n => `${midiToName(n.midi)}:${Number(n.durBeats).toFixed(3)}`).join(", ");
    }

    copyBtn.addEventListener("click", async () => {
      if(!phrase) return;
      const txt = phraseText(phrase);
      try{
        await navigator.clipboard.writeText(txt);
        setWarn(null);
      }catch(e){
        setWarn("Clipboard blocked by browser. Select/copy manually from the output box.");
      }
    });

    function exportMIDI(notes, bpm){
      const PPQ = 480;
      const u16 = n => [(n>>8)&255, n&255];
      const u32 = n => [(n>>24)&255, (n>>16)&255, (n>>8)&255, n&255];
      const str = s => Array.from(s).map(c=>c.charCodeAt(0));
      function vlq(n){
        let bytes = [n & 0x7F];
        while((n >>= 7)) bytes.unshift((n & 0x7F) | 0x80);
        return bytes;
      }

      const header = [...str("MThd"), ...u32(6), ...u16(0), ...u16(1), ...u16(PPQ)];
      const ev = [];

      // tempo meta
      const mpqn = Math.round(60000000 / Math.max(1, bpm));
      ev.push(...vlq(0), 0xFF, 0x51, 0x03, (mpqn>>16)&255, (mpqn>>8)&255, mpqn&255);
      // program change (piano)
      ev.push(...vlq(0), 0xC0, 0x00);

      for(const n of notes){
        const durTicks = Math.max(1, Math.round(n.durBeats * PPQ));
        ev.push(...vlq(0),      0x90, clamp(n.midi,0,127), 100); // note on
        ev.push(...vlq(durTicks),0x80, clamp(n.midi,0,127), 0);  // note off
      }
      // end track
      ev.push(...vlq(0), 0xFF, 0x2F, 0x00);

      const track = [...str("MTrk"), ...u32(ev.length), ...ev];
      const bytes = new Uint8Array([...header, ...track]);
      const blob = new Blob([bytes], {type:"audio/midi"});
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "generated_phrase.mid";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    midiBtn.addEventListener("click", () => {
      if(!phrase) return;
      exportMIDI(phrase, Number(tempoEl.value));
    });

    // -------------------------
    // Ratings + Evidence plots
    // -------------------------
    const RATINGS_KEY = "liam_ai_music_ratings_v2_simple";

    function loadRatings(){
      try{ return JSON.parse(localStorage.getItem(RATINGS_KEY) || "[]"); }
      catch(e){ return []; }
    }
    function saveRatings(list){
      localStorage.setItem(RATINGS_KEY, JSON.stringify(list));
    }

    function setStars(n){
      currentStars = n;
      starsWrap.querySelectorAll(".star").forEach(el => {
        const s = Number(el.dataset.s);
        el.classList.toggle("on", s <= n);
      });
      saveBtn.disabled = !(phrase && currentStars>0);
    }

    starsWrap.addEventListener("click", (e) => {
      const el = e.target.closest(".star");
      if(!el) return;
      setStars(Number(el.dataset.s));
    });

    function renderTable(){
      const list = loadRatings();
      if(!list.length){
        ratingsBody.innerHTML = `<tr><td colspan="3" class="tiny">No ratings yet.</td></tr>`;
        return;
      }
      const view = list.slice(-10).reverse();
      ratingsBody.innerHTML = view.map(r => `
        <tr>
          <td>${"★".repeat(r.stars)}${"☆".repeat(5-r.stars)}</td>
          <td>${r.key} ${r.mode.replaceAll("_"," ")} • tempo ${r.bpm} • bias ${Number(r.bias).toFixed(2)}</td>
          <td>${r.length}</td>
        </tr>
      `).join("");
    }

    function downloadText(filename, text, type){
      const blob = new Blob([text], {type: type || "text/plain"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    }

    saveBtn.addEventListener("click", () => {
      if(!phrase || !currentStars) return;

      const key = keyEl.value;
      const mode = modeEl.value;
      const bpm = Number(tempoEl.value);
      const bias = Number(biasEl.value);
      const length = Number(lenEl.value);

      const m = metrics(phrase, key, mode);
      const entry = {
        ts: nowISO(),
        stars: currentStars,
        comment: (commentEl.value || "").trim(),
        key, mode, bpm, bias, length,
        metrics: m,
        phrase: phrase.map(n => ({midi:n.midi, durBeats:n.durBeats}))
      };

      const list = loadRatings();
      list.push(entry);
      saveRatings(list);

      commentEl.value = "";
      setStars(0);
      renderTable();
      renderPlots();
      setWarn(null);
    });

    csvBtn.addEventListener("click", () => {
      const list = loadRatings();
      if(!list.length){ setWarn("No ratings to export yet."); return; }

      const header = [
        "ts","stars","comment","key","mode","bpm","bias","length",
        "repetition","stepwise","range","tonal","phrase"
      ];

      const esc = (s) => `"${String(s ?? "").replaceAll('"','""')}"`;
      const rows = list.map(r => {
        const phr = r.phrase.map(n => `${midiToName(n.midi)}:${Number(n.durBeats).toFixed(3)}`).join(" ");
        return [
          esc(r.ts),
          r.stars,
          esc(r.comment),
          esc(r.key),
          esc(r.mode),
          r.bpm,
          r.bias,
          r.length,
          (r.metrics?.repetition ?? "").toFixed?.(4) ?? "",
          (r.metrics?.stepwise ?? "").toFixed?.(4) ?? "",
          r.metrics?.range ?? "",
          (r.metrics?.tonal ?? "").toFixed?.(4) ?? "",
          esc(phr)
        ].join(",");
      });

      downloadText("ai_music_ratings.csv", [header.join(","), ...rows].join("\n"), "text/csv");
      setWarn(null);
    });

    clearBtn.addEventListener("click", () => {
      localStorage.removeItem(RATINGS_KEY);
      renderTable();
      renderPlots();
      setWarn(null);
    });

    // Simple bar chart (minimal code)
    function barChart(canvas, labels, values, title){
      const cssH = 200;
      const {ctx, w, h} = fitCanvas(canvas, cssH);
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = "rgba(5,5,12,0.85)";
      ctx.fillRect(0,0,w,h);

      const padL = 44, padR = 12, padT = 28, padB = 36;
      const innerW = w - padL - padR;
      const innerH = h - padT - padB;

      ctx.fillStyle = "rgba(238,240,255,0.85)";
      ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText(title || "", 12, 18);

      const maxV = Math.max(1e-9, ...values);
      const n = values.length;
      const gap = 8;
      const barW = Math.max(6, (innerW - gap*(n-1)) / n);

      // axes
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, padT + innerH);
      ctx.lineTo(padL + innerW, padT + innerH);
      ctx.stroke();

      // y ticks (0..max)
      ctx.fillStyle = "rgba(238,240,255,0.65)";
      ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
      for(let t=0;t<=2;t++){
        const yVal = (maxV * t/2);
        const y = padT + innerH - (innerH * t/2);
        ctx.fillText(String(yVal.toFixed(1)).replace(".0",""), 8, y+4);
        ctx.strokeStyle = "rgba(255,255,255,0.06)";
        ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(padL+innerW, y); ctx.stroke();
      }

      // bars
      for(let i=0;i<n;i++){
        const v = values[i];
        const bh = (v/maxV)*innerH;
        const x = padL + i*(barW+gap);
        const y = padT + innerH - bh;

        ctx.fillStyle = "rgba(120,140,255,0.42)";
        ctx.strokeStyle = "rgba(120,140,255,0.85)";
        roundRect(ctx, x, y, barW, bh, 8);
        ctx.fill(); ctx.stroke();

        // x labels
        ctx.fillStyle = "rgba(238,240,255,0.70)";
        ctx.font = "11px " + getComputedStyle(document.body).fontFamily;
        const lab = labels[i];
        const tx = x + barW/2;
        ctx.save();
        ctx.translate(tx, padT + innerH + 14);
        ctx.rotate(-0.35);
        ctx.textAlign = "center";
        ctx.fillText(lab, 0, 0);
        ctx.restore();
      }
    }

    function renderPlots(){
      const list = loadRatings();

      // Plot 1: star distribution
      const counts = [1,2,3,4,5].map(s => list.filter(r => r.stars===s).length);
      barChart(plot1, ["1","2","3","4","5"], counts, "Rating distribution (counts)");

      // Plot 2: avg rating by mode
      const byMode = {};
      for(const r of list){
        const k = r.mode;
        if(!byMode[k]) byMode[k] = {sum:0, n:0};
        byMode[k].sum += r.stars; byMode[k].n += 1;
      }
      const modeItems = Object.entries(byMode)
        .map(([k,v]) => ({k, avg: v.sum / Math.max(1,v.n), n:v.n}))
        .sort((a,b)=> (b.n - a.n) || (b.avg - a.avg))
        .slice(0, 6);

      barChart(
        plot2,
        modeItems.length ? modeItems.map(x => x.k.replaceAll("_"," ")) : ["—"],
        modeItems.length ? modeItems.map(x => Number(x.avg.toFixed(2))) : [0],
        "Average rating by mode"
      );

      // Plot 3: avg rating by bias bucket
      const buckets = {}; // "0.00", "0.25", ...
      const bucketOf = (b) => (Math.round(b/0.25)*0.25).toFixed(2);
      for(const r of list){
        const k = bucketOf(Number(r.bias));
        if(!buckets[k]) buckets[k] = {sum:0,n:0};
        buckets[k].sum += r.stars; buckets[k].n += 1;
      }
      const bucketKeys = ["0.00","0.25","0.50","0.75","1.00"];
      const bucketVals = bucketKeys.map(k => buckets[k] ? (buckets[k].sum / buckets[k].n) : 0);

      barChart(plot3, bucketKeys, bucketVals, "Average rating by stepwise bias bucket");
    }

    // -------------------------
    // Main actions
    // -------------------------
    genBtn.addEventListener("click", () => {
      stopPlayback();
      setWarn(null);

      const key = keyEl.value;
      const mode = modeEl.value;
      const bias = Number(biasEl.value);
      const length = Number(lenEl.value);

      outEl.textContent = "Generating...";
      try{
        phrase = generate({key, mode, bias, length});
        renderPhrase(phrase);

        const m = metrics(phrase, key, mode);
        renderMetrics(m);

        drawRoll(phrase);

        playBtn.disabled = false;
        copyBtn.disabled = false;
        midiBtn.disabled = false;

        saveBtn.disabled = !(currentStars>0);
      }catch(e){
        phrase = null;
        outEl.textContent = "(generation failed)";
        playBtn.disabled = true; stopBtn.disabled = true; copyBtn.disabled = true; midiBtn.disabled = true; saveBtn.disabled = true;
        drawRoll(null);
        renderMetrics({repetition:0,stepwise:0,range:0,tonal:0});
        setWarn(e?.message || "Generation failed.");
      }
    });

    playBtn.addEventListener("click", async () => {
      if(!phrase) return;
      setWarn(null);
      try{
        await ensureAudio();
        stopPlayback();
        schedulePlayback(phrase);
        playBtn.disabled = true;
        stopBtn.disabled = false;
      }catch(e){
        setWarn("Audio blocked by browser. Click Play again (or interact once more) to enable sound.");
      }
    });

    stopBtn.addEventListener("click", stopPlayback);

    window.addEventListener("keydown", (e) => {
      const tag = (document.activeElement?.tagName || "").toLowerCase();
      if(tag === "input" || tag === "textarea" || tag === "select") return;

      if(e.code === "Space"){
        e.preventDefault();
        if(!stopBtn.disabled) stopPlayback();
        else if(!playBtn.disabled) playBtn.click();
      }else if(e.key.toLowerCase() === "g"){
        genBtn.click();
      }else if(e.key.toLowerCase() === "c"){
        if(!copyBtn.disabled) copyBtn.click();
      }else if(e.key.toLowerCase() === "m"){
        if(!midiBtn.disabled) midiBtn.click();
      }
    });

    // Initial render
    renderTable();
    renderPlots();
    drawRoll(null);
    biasVal.textContent = Number(biasEl.value).toFixed(2);
    tempoVal.textContent = tempoEl.value;
  </script>
</body>
</html>









