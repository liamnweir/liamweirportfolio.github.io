<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Music Generation System | Liam Weir</title>

  <!-- Tone.js (audio playback) -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>

  <style>
    * { box-sizing: border-box; }

    body{
      margin:0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto;
      background:#0a0a12;
      color:#eef0ff;
    }

    /* REPLACEMENT TOP BAR (Back button only) */
    .top-bar{
      position:fixed;
      top:0;
      left:0;
      width:100%;
      background: rgba(10,10,25,0.85);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      justify-content:flex-start;
      padding: 1rem 1.2rem;
      z-index: 100;
    }

    .back-btn{
      display:inline-flex;
      align-items:center;
      gap: 0.45rem;
      color:#eef0ff;
      text-decoration:none;
      font-weight: 800;
      letter-spacing: 0.2px;
      padding: 0.55rem 0.95rem;
      border-radius: 14px;
      background: rgba(120,140,255,0.18);
      border: 1px solid rgba(120,140,255,0.35);
      transition: transform 0.15s ease, filter 0.15s ease;
    }

    .back-btn:hover{
      filter: brightness(1.15);
      transform: translateY(-1px);
    }

    main{
      max-width: 1100px;
      margin: 0 auto;
      padding: 96px 18px 48px; /* keeps spacing correct with fixed top bar */
    }

    h1{
      font-size: 2.4rem;
      margin: 0 0 10px;
    }
    p{ opacity:0.9; line-height:1.6; }

    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 18px;
      margin-top: 18px;
    }
    @media (max-width: 920px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 20px;
      padding: 18px;
      box-shadow: 0 30px 60px rgba(0,0,0,0.35);
    }

    .label{
      font-size: 0.9rem;
      opacity: 0.85;
      margin-bottom: 6px;
    }

    select, input[type="range"], input[type="text"]{
      background: rgba(255,255,255,0.06);
      color: #eef0ff;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 12px;
      outline: none;
      min-width: 170px;
    }

    input[type="range"]{
      padding: 10px 0;
      min-width: 240px;
    }

    .btn{
      background: rgba(120,140,255,0.18);
      border: 1px solid rgba(120,140,255,0.35);
      color:#eef0ff;
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 700;
      letter-spacing: 0.2px;
      transition: transform 0.15s ease, filter 0.15s ease;
    }
    .btn:hover{ filter: brightness(1.15); transform: translateY(-1px); }
    .btn:disabled{ opacity:0.45; cursor:not-allowed; transform:none; }

    pre{
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 12px;
      overflow:auto;
      white-space: pre;
      margin: 10px 0 0;
      min-height: 180px;
    }

    .pill{
      display:inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      font-size: 0.85rem;
      opacity: 0.9;
      margin-right: 6px;
      margin-top: 10px;
    }

    .muted{ opacity: 0.8; }

    .metric{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .metric:last-child{ border-bottom:none; }

    .tiny{
      font-size: 0.85rem;
      opacity: 0.75;
    }

    .warn{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,180,120,0.25);
      background: rgba(255,180,120,0.08);
      color: #ffe9da;
      display:none;
    }

    /* =========================================================
       NEW: Piano roll (make it fully visible + scroll-free view)
       ========================================================= */
    .pianoroll-wrap{
      margin-top: 14px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      overflow: hidden;
    }

    .pianoroll-head{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03);
    }

    .pianoroll-title{
      font-weight: 800;
      letter-spacing: 0.2px;
      margin: 0;
      font-size: 0.95rem;
      opacity: 0.95;
    }

    .pianoroll-actions{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
      justify-content:flex-end;
    }

    .toggle{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      user-select:none;
      cursor:pointer;
      font-size: 0.88rem;
      opacity: 0.95;
    }

    .toggle input{ transform: translateY(1px); }

    /* The canvas is what we will dynamically size to fully show melody */
    canvas#pianoRoll{
      display:block;
      width: 100%;
      height: auto;       /* keep aspect ratio / show full content */
      background: rgba(5,5,12,0.65);
    }

    .pianoroll-foot{
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,0.08);
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content:space-between;
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 0.85rem;
      opacity: 0.9;
    }

    /* =========================================================
       NEW: Extra sections to "transcend" the program (nice layout)
       ========================================================= */
    .stack{
      display:grid;
      gap: 18px;
      margin-top: 18px;
    }

    .two-col{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
    }
    @media (max-width: 920px){ .two-col{ grid-template-columns: 1fr; } }

    .list{
      margin: 10px 0 0;
      padding-left: 18px;
      opacity: 0.92;
      line-height: 1.65;
    }

    .divider{
      border:0;
      border-top:1px solid rgba(255,255,255,0.08);
      margin: 14px 0;
    }

    .chip{
      display:inline-block;
      margin: 6px 6px 0 0;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(120,140,255,0.10);
      font-size: 0.86rem;
      opacity: 0.95;
    }

    .rating-row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      margin-top: 8px;
    }

    .starbar{
      display:inline-flex;
      gap: 6px;
      align-items:center;
    }

    .star{
      width: 34px;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      cursor:pointer;
      display:grid;
      place-items:center;
      font-size: 18px;
      transition: transform 0.12s ease, filter 0.12s ease;
      user-select:none;
    }
    .star:hover{ transform: translateY(-1px); filter: brightness(1.1); }
    .star.on{
      background: rgba(120,140,255,0.22);
      border-color: rgba(120,140,255,0.45);
    }

    .mini-btn{
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 0.9rem;
    }

    table{
      width:100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 0.92rem;
      opacity: 0.95;
    }
    th, td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      vertical-align: top;
    }
    th{
      text-align:left;
      opacity: 0.85;
      font-weight: 800;
    }
  </style>
</head>

<body>
  <!-- Back button only (replaces broken nav) -->
  <div class="top-bar">
    <a class="back-btn" href="https://liamnweir.github.io/liamweirportfolio.github.io/">
      ← Back to Home
    </a>
  </div>

  <main>
    <h1>AI Music Generation System</h1>
    <p class="muted">
      Generate short symbolic phrases with musical structure + simple perception metrics.
      This page runs on GitHub Pages (static). If you want a real ML model, this UI can call a Hugging Face Spaces backend (optional).
    </p>

    <div>
      <span class="pill">AI</span>
      <span class="pill">Music</span>
      <span class="pill">Perception</span>
      <span class="pill">Tone.js</span>
      <span class="pill">GitHub Pages</span>
    </div>

    <div class="grid">
      <section class="card">
        <h2 style="margin:0 0 10px;">Interactive Demo</h2>

        <div class="row">
          <div>
            <div class="label">Key</div>
            <select id="key">
              <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
              <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
              <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
            </select>
          </div>

          <div>
            <div class="label">Scale / Mode</div>
            <select id="mode">
              <option value="major">Major (Ionian)</option>
              <option value="natural_minor">Natural Minor (Aeolian)</option>
              <option value="harmonic_minor">Harmonic Minor</option>
              <option value="melodic_minor">Melodic Minor (Ascending)</option>
              <option value="dorian">Dorian</option>
              <option value="mixolydian">Mixolydian</option>
              <option value="lydian">Lydian</option>
              <option value="phrygian">Phrygian</option>
              <option value="locrian">Locrian</option>
            </select>
          </div>

          <div style="min-width: 260px;">
            <div class="label">Tempo: <span id="tempoVal">110</span> BPM</div>
            <input id="tempo" type="range" min="70" max="170" value="110" />
          </div>

          <div style="min-width: 280px;">
            <div class="label">Stepwise Bias: <span id="smoothVal">0.75</span></div>
            <input id="smooth" type="range" min="0" max="1" step="0.01" value="0.75" />
          </div>

          <div>
            <div class="label">Length</div>
            <select id="length">
              <option value="8">8 notes</option>
              <option value="16" selected>16 notes</option>
              <option value="24">24 notes</option>
              <option value="32">32 notes</option>
            </select>
          </div>

          <div>
            <div class="label">Instrument</div>
            <select id="instrument">
              <option value="piano" selected>Piano</option>
              <option value="guitar">Guitar (plucked)</option>
              <option value="bass">Bass</option>
              <option value="violin">Violin</option>
              <option value="strings">Strings (pad)</option>
              <option value="synth">Synth (bright)</option>
            </select>
          </div>

          <div style="min-width: 260px;">
            <div class="label">Generation Source</div>
            <select id="source">
              <option value="browser" selected>Browser (demo generator)</option>
              <option value="hf">Hugging Face (ML backend)</option>
            </select>
          </div>

          <div style="min-width: 360px; flex: 1;">
            <div class="label">HF Space API URL (optional)</div>
            <input id="backendUrl" type="text" placeholder="https://YOUR-SPACE.hf.space/generate" />
            <div class="tiny">
              Leave blank if using the browser generator. If using HF, paste your Space endpoint here.
            </div>
          </div>

          <div class="row" style="align-items:center;">
            <button class="btn" id="generateBtn">Generate</button>
            <button class="btn" id="playBtn" disabled>Play</button>
            <button class="btn" id="stopBtn" disabled>Stop</button>
            <!-- NEW: export + copy -->
            <button class="btn" id="copyBtn" disabled>Copy Notes</button>
            <button class="btn" id="exportMidiBtn" disabled>Export MIDI</button>
          </div>
        </div>

        <div id="warnBox" class="warn"></div>

        <div class="label" style="margin-top: 12px;">Generated phrase (notes + durations)</div>
        <pre id="out">(click Generate)</pre>

        <!-- NEW: Piano Roll (auto-sized to fully show melody) -->
        <div class="pianoroll-wrap" aria-label="Piano roll">
          <div class="pianoroll-head">
            <p class="pianoroll-title">Piano Roll (full melody view)</p>
            <div class="pianoroll-actions">
              <label class="toggle" title="If enabled, the piano roll height expands to include all notes with padding.">
                <input id="fitRoll" type="checkbox" checked />
                Fit to melody
              </label>
              <label class="toggle" title="Shows a faint beat grid behind notes.">
                <input id="gridRoll" type="checkbox" checked />
                Grid
              </label>
              <label class="toggle" title="Shows note names on the left.">
                <input id="labelsRoll" type="checkbox" checked />
                Labels
              </label>
            </div>
          </div>
          <canvas id="pianoRoll" width="980" height="260"></canvas>
          <div class="pianoroll-foot">
            <div class="tiny muted">
              Shortcuts: <span class="kbd">Space</span> play/stop • <span class="kbd">G</span> generate • <span class="kbd">C</span> copy • <span class="kbd">M</span> export MIDI
            </div>
            <div class="tiny muted" id="rollInfo">—</div>
          </div>
        </div>

        <p class="tiny muted" style="margin-top: 10px;">
          Tip: “Harmonic/Melodic minor” modes are great for showing musical structure in your writeup.
          If you switch the source to “Hugging Face,” the page will call your backend and keep the same UI.
        </p>
      </section>

      <aside class="card">
        <h2 style="margin:0 0 10px;">Perception / Structure Metrics</h2>
        <p class="muted" style="margin-top:0;">
          Simple heuristics you can report now, then validate with listening tests later.
        </p>

        <div class="metric"><span>Repetition Score</span><strong id="repScore">—</strong></div>
        <div class="metric"><span>Stepwise Motion</span><strong id="stepScore">—</strong></div>
        <div class="metric"><span>Range (semitones)</span><strong id="rangeScore">—</strong></div>
        <div class="metric"><span>Tonal Stability</span><strong id="tonalScore">—</strong></div>

        <!-- NEW: musical explanation (auto-updated per phrase) -->
        <hr style="border:0; border-top:1px solid rgba(255,255,255,0.08); margin:14px 0;" />
        <h3 style="margin:0 0 8px;">Melody idea (why it works)</h3>
        <p class="muted" style="margin-top:0;" id="melodyExplain">
          Generate a phrase to see a short explanation of its contour + cadence.
        </p>

        <hr style="border:0; border-top:1px solid rgba(255,255,255,0.08); margin:14px 0;" />

        <h3 style="margin:0 0 8px;">What to write about</h3>
        <p class="muted" style="margin-top:0;">
          • Dataset (MIDI phrases)<br/>
          • Model (Transformer/VAE) or rule-based baseline<br/>
          • Constraints (key/mode, contour, cadence)<br/>
          • Evaluation (listener ratings + metrics)<br/>
          • Demo (this page) + backend endpoint
        </p>
      </aside>
    </div>

    <!-- =========================================================
         NEW: “Transcend the program” sections (ratings + research)
         ========================================================= -->
    <div class="stack">
      <section class="card">
        <h2 style="margin:0 0 6px;">Listening Study (User Ratings)</h2>
        <p class="muted" style="margin-top:0;">
          This adds a lightweight, on-page evaluation loop: listeners rate the generated phrase, and the page stores ratings locally (in your browser) so you can export a CSV later.
        </p>

        <div class="two-col">
          <div>
            <div class="label">Rate this phrase</div>
            <div class="rating-row">
              <div class="starbar" id="starBar" aria-label="Star rating">
                <div class="star" data-star="1">★</div>
                <div class="star" data-star="2">★</div>
                <div class="star" data-star="3">★</div>
                <div class="star" data-star="4">★</div>
                <div class="star" data-star="5">★</div>
              </div>
              <span class="tiny muted" id="ratingHint">Generate a phrase, then rate it.</span>
            </div>

            <div class="label" style="margin-top:10px;">Optional comment</div>
            <input id="ratingComment" type="text" placeholder="e.g., 'Nice cadence but too repetitive'" style="width:100%; min-width: unset;" />

            <div class="row" style="margin-top:12px;">
              <button class="btn mini-btn" id="saveRatingBtn" disabled>Save Rating</button>
              <button class="btn mini-btn" id="exportRatingsBtn">Export Ratings (CSV)</button>
              <button class="btn mini-btn" id="clearRatingsBtn">Clear Local Ratings</button>
            </div>
            <div class="tiny muted" style="margin-top:10px;">
              Stored locally via <span class="kbd">localStorage</span> (no server needed). If you later add a backend, you can POST these ratings to your database.
            </div>
          </div>

          <div>
            <div class="label">Saved ratings (this device)</div>
            <table>
              <thead>
                <tr>
                  <th style="width: 110px;">Stars</th>
                  <th>Key/Mode</th>
                  <th style="width: 140px;">Length</th>
                </tr>
              </thead>
              <tbody id="ratingsTable">
                <tr><td colspan="3" class="tiny muted">No ratings yet.</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>

      <section class="card">
        <h2 style="margin:0 0 6px;">Paper-Style Writeup (drop-in)</h2>
        <p class="muted" style="margin-top:0;">
          This is a ready-to-paste “mini paper” outline that matches what your demo actually does (baseline generator + metrics + listening study). You can expand it when you add a Transformer backend.
        </p>

        <hr class="divider"/>

        <h3 style="margin:0;">Abstract</h3>
        <p class="muted">
          We present a browser-based system for generating short symbolic melodies under musical constraints (key/mode, contour bias, cadence bias). We evaluate phrases using simple structure metrics (repetition, stepwise motion, range, tonal stability) and collect listener ratings through an embedded survey interface. The system supports a local rule-based baseline and optional integration with a machine-learning backend via a Hugging Face Space endpoint.
        </p>

        <div class="two-col">
          <div>
            <h3 style="margin:0;">Method</h3>
            <ul class="list">
              <li><strong>Generator:</strong> stepwise-biased random walk constrained to a mode; soft arch-shaped contour; cadence pull at phrase end.</li>
              <li><strong>Interface:</strong> interactive controls for key, mode, tempo, phrase length, timbre.</li>
              <li><strong>Playback:</strong> Tone.js synth approximations (no samples required).</li>
            </ul>
          </div>
          <div>
            <h3 style="margin:0;">Evaluation</h3>
            <ul class="list">
              <li><strong>Objective metrics:</strong> repetition, stepwise motion, range, tonal stability.</li>
              <li><strong>Subjective:</strong> 1–5 star rating + optional comment stored locally (exportable CSV).</li>
              <li><strong>Future:</strong> compare baseline vs. Transformer via AB tests.</li>
            </ul>
          </div>
        </div>

        <hr class="divider"/>

        <h3 style="margin:0;">Results & Discussion (how to talk about it)</h3>
        <p class="muted" style="margin-top:8px;">
          The contour + cadence biases increase perceived “phrase-ness” (a sense of beginning, middle, end). Stepwise bias increases singability and reduces large leaps; tonal stability reflects how often tones land on chord tones, which often correlates with “resolved” sounding melodies. In future work, listener ratings can be analyzed against these metrics (e.g., do high-rated phrases have higher tonal stability but moderate repetition?).
        </p>

        <div style="margin-top:10px;">
          <span class="chip">Baseline vs ML comparison</span>
          <span class="chip">AB listening tests</span>
          <span class="chip">Metric–rating correlation</span>
          <span class="chip">Exportable dataset of ratings</span>
        </div>
      </section>
    </div>
  </main>

  <script>
    // ----------------------------
    // Music theory helpers
    // ----------------------------
    const NOTE_TO_SEMITONE = {
      "C":0,"C#":1,"D":2,"D#":3,"E":4,"F":5,"F#":6,"G":7,"G#":8,"A":9,"A#":10,"B":11
    };

    // Scale degrees as semitone offsets from tonic within an octave
    const MODES = {
      major:         [0,2,4,5,7,9,11],      // Ionian
      natural_minor: [0,2,3,5,7,8,10],      // Aeolian
      harmonic_minor:[0,2,3,5,7,8,11],      // raised 7
      melodic_minor: [0,2,3,5,7,9,11],      // raised 6 & 7 (ascending)
      dorian:        [0,2,3,5,7,9,10],
      mixolydian:    [0,2,4,5,7,9,10],
      lydian:        [0,2,4,6,7,9,11],
      phrygian:      [0,1,3,5,7,8,10],
      locrian:       [0,1,3,5,6,8,10]
    };

    function pick(arr){ return arr[Math.floor(Math.random() * arr.length)]; }

    function midiToNoteName(m){
      const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
      const name = names[m % 12];
      const oct = Math.floor(m / 12) - 1;
      return `${name}${oct}`;
    }

    function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

    // ----------------------------
    // UI elements
    // ----------------------------
    const tempo = document.getElementById("tempo");
    const tempoVal = document.getElementById("tempoVal");
    const smooth = document.getElementById("smooth");
    const smoothVal = document.getElementById("smoothVal");
    const generateBtn = document.getElementById("generateBtn");
    const playBtn = document.getElementById("playBtn");
    const stopBtn = document.getElementById("stopBtn");
    const out = document.getElementById("out");

    const repScoreEl = document.getElementById("repScore");
    const stepScoreEl = document.getElementById("stepScore");
    const rangeScoreEl = document.getElementById("rangeScore");
    const tonalScoreEl = document.getElementById("tonalScore");

    const warnBox = document.getElementById("warnBox");

    // NEW UI
    const copyBtn = document.getElementById("copyBtn");
    const exportMidiBtn = document.getElementById("exportMidiBtn");

    const pianoRoll = document.getElementById("pianoRoll");
    const rollInfo = document.getElementById("rollInfo");
    const fitRoll = document.getElementById("fitRoll");
    const gridRoll = document.getElementById("gridRoll");
    const labelsRoll = document.getElementById("labelsRoll");

    const melodyExplain = document.getElementById("melodyExplain");

    const starBar = document.getElementById("starBar");
    const ratingHint = document.getElementById("ratingHint");
    const ratingComment = document.getElementById("ratingComment");
    const saveRatingBtn = document.getElementById("saveRatingBtn");
    const exportRatingsBtn = document.getElementById("exportRatingsBtn");
    const clearRatingsBtn = document.getElementById("clearRatingsBtn");
    const ratingsTable = document.getElementById("ratingsTable");

    tempo.addEventListener("input", () => tempoVal.textContent = tempo.value);
    smooth.addEventListener("input", () => smoothVal.textContent = Number(smooth.value).toFixed(2));

    // ----------------------------
    // State
    // ----------------------------
    let phrase = null;      // [{midi, durBeats}, ...]
    let instrument = null;  // Tone instrument instance
    let part = null;        // Tone.Part

    // NEW rating state
    let currentStars = 0;

    // ----------------------------
    // Instrument factory (no external samples required)
    // Labels match common instruments, but these are synth approximations.
    // ----------------------------
    function makeInstrument(kind){
      // Dispose previous instrument cleanly
      if (instrument) {
        try { instrument.dispose(); } catch(e) {}
        instrument = null;
      }

      // Small reverb to make it nicer
      const reverb = new Tone.Reverb({ decay: 2.2, wet: 0.15 }).toDestination();

      if (kind === "piano"){
        // PolySynth "piano-ish"
        instrument = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: "triangle" },
          envelope: { attack: 0.005, decay: 0.25, sustain: 0.15, release: 0.9 }
        }).connect(reverb);

      } else if (kind === "guitar"){
        // Plucked string
        instrument = new Tone.PolySynth(Tone.PluckSynth, {
          volume: -6
        }).connect(reverb);

      } else if (kind === "bass"){
        // Mono bass
        instrument = new Tone.MonoSynth({
          oscillator: { type: "sine" },
          filter: { Q: 2, type: "lowpass", rolloff: -24 },
          envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.4 },
          filterEnvelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2, baseFrequency: 80, octaves: 2.2 }
        }).connect(reverb);

      } else if (kind === "violin"){
        // Bowed-ish (saw + slower attack + vibrato)
        const vib = new Tone.Vibrato(5, 0.18).connect(reverb);
        instrument = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: "sawtooth" },
          envelope: { attack: 0.06, decay: 0.15, sustain: 0.65, release: 0.6 }
        }).connect(vib);

      } else if (kind === "strings"){
        // Soft pad
        const chorus = new Tone.Chorus(2.5, 1.6, 0.25).start().connect(reverb);
        instrument = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: "sawtooth" },
          envelope: { attack: 0.2, decay: 0.2, sustain: 0.75, release: 1.4 }
        }).connect(chorus);

      } else {
        // synth (bright)
        const delay = new Tone.FeedbackDelay("8n", 0.25).connect(reverb);
        instrument = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: "square" },
          envelope: { attack: 0.01, decay: 0.12, sustain: 0.2, release: 0.25 }
        }).connect(delay);
      }

      return instrument;
    }

    // ----------------------------
    // Browser generator (demo baseline)
    // ----------------------------
    function buildAllowedNotes(rootSemitone, modeKey){
      const scale = MODES[modeKey].map(x => x + rootSemitone); // 0..11-ish
      const baseOctave = 60; // C4
      const allowed = [];
      // Use a 3-octave window centered around C4-ish
      for (let oct = -1; oct <= 1; oct++){
        for (const s of scale){
          allowed.push(baseOctave + s + 12*oct);
        }
      }
      return allowed.sort((a,b)=>a-b);
    }

    function generatePhraseBrowser({ key, mode, smooth, length }){
      const root = NOTE_TO_SEMITONE[key];
      const allowed = buildAllowedNotes(root, mode);

      // Start near tonic in middle octave
      const tonicMidi = 60 + root;
      let current = tonicMidi;

      const notes = [];
      const N = length;

      // Phrase shape helper: encourage a gentle arch (rise then fall)
      const mid = Math.floor(N / 2);

      for (let i = 0; i < N; i++){
        const neighbors = allowed.filter(n => Math.abs(n - current) <= 2); // step/whole-step
        const broader = allowed;

        // Step bias chooses neighbor vs broader pool
        let pool = (Math.random() < smooth && neighbors.length) ? neighbors : broader;

        // Gentle contour bias: rising first half, falling second half (softly)
        const target = (i <= mid) ? current + 2 : current - 2;
        pool = pool
          .map(n => ({ n, w: 1 / (1 + Math.abs(n - target)) }))
          .sort((a,b)=>b.w - a.w)
          .slice(0, Math.max(6, Math.floor(pool.length * 0.35)))
          .map(x => x.n);

        // Cadence bias: last 2 notes pull toward tonic or dominant
        if (i >= N - 2){
          const domMidi = tonicMidi + 7;
          const nearCadence = allowed.filter(n => Math.min(Math.abs(n - tonicMidi), Math.abs(n - domMidi)) <= 3);
          if (nearCadence.length) pool = nearCadence;
        }

        current = pick(pool);

        // rhythm: mostly eighth notes, occasional quarters
        let durBeats = 0.5;
        if (Math.random() < 0.14) durBeats = 1.0;      // quarter
        if (i === N - 1) durBeats = 1.0;               // finish slightly longer

        notes.push({ midi: current, durBeats });
      }

      return notes;
    }

    // ----------------------------
    // Metrics
    // ----------------------------
    function computeMetrics(notes, key, mode){
      const midis = notes.map(n => n.midi);
      const unique = new Set(midis);
      const repetition = 1 - (unique.size / midis.length); // higher = more repetition

      let stepCount = 0;
      for (let i=1; i<midis.length; i++){
        const interval = Math.abs(midis[i] - midis[i-1]);
        if (interval <= 2) stepCount++;
      }
      const stepwise = stepCount / Math.max(1, (midis.length - 1));

      const range = Math.max(...midis) - Math.min(...midis);

      // Tonal stability: fraction of notes that are tonic/third/fifth (triad) in chosen mode
      const root = NOTE_TO_SEMITONE[key];
      // triad degrees for "major-ish" vs "minor-ish"
      const isMinorish = (mode.includes("minor") || mode === "dorian" || mode === "phrygian" || mode === "locrian");
      const triad = isMinorish ? [0, 3, 7] : [0, 4, 7];
      const triadPC = new Set(triad.map(x => (x + root) % 12));
      const tonal = midis.filter(m => triadPC.has(m % 12)).length / midis.length;

      return { repetition, stepwise, range, tonal };
    }

    function renderPhrase(notes){
      const lines = notes.map((n, i) => `${String(i+1).padStart(2,"0")}. ${midiToNoteName(n.midi)}  (${n.durBeats} beats)`);
      out.textContent = lines.join("\n");
    }

    function renderMetrics(metrics){
      repScoreEl.textContent = metrics.repetition.toFixed(2);
      stepScoreEl.textContent = metrics.stepwise.toFixed(2);
      rangeScoreEl.textContent = String(metrics.range);
      tonalScoreEl.textContent = metrics.tonal.toFixed(2);
    }

    function setWarning(msg){
      if (!msg){
        warnBox.style.display = "none";
        warnBox.textContent = "";
        return;
      }
      warnBox.style.display = "block";
      warnBox.textContent = msg;
    }

    // ----------------------------
    // Hugging Face backend call
    // Expected endpoint: POST <backendUrl>
    // Body: { key, mode, tempo, smooth, length }
    // Response: { notes: [{midi, durBeats}, ...] } (and optionally metrics)
    // ----------------------------
    async function generateFromHF({ backendUrl, key, mode, tempo, smooth, length }){
      const res = await fetch(backendUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ key, mode, tempo, smooth, length })
      });

      if (!res.ok){
        const text = await res.text().catch(()=> "");
        throw new Error(`HF backend error (${res.status}). ${text}`.trim());
      }
      const data = await res.json();
      if (!data || !Array.isArray(data.notes)) throw new Error("HF backend response missing `notes` array.");
      return data;
    }

    // ----------------------------
    // Playback
    // ----------------------------
    async function ensureAudio(){
      if (Tone.context.state !== "running") await Tone.start();
      const kind = document.getElementById("instrument").value;
      makeInstrument(kind);
    }

    function stopPlayback(){
      if (part){
        part.stop();
        part.dispose();
        part = null;
      }
      Tone.Transport.stop();
      Tone.Transport.cancel();
      playBtn.disabled = !phrase;
      stopBtn.disabled = true;
    }

    function schedulePlayback(notes){
      // Bass sounds better lower: transpose down a bit for bass preset
      const instKind = document.getElementById("instrument").value;
      const transpose = (instKind === "bass") ? -12 : 0;

      Tone.Transport.bpm.value = Number(document.getElementById("tempo").value);

      let t = 0;
      const events = notes.map(n => {
        const midi = clamp(n.midi + transpose, 24, 108);
        const noteName = midiToNoteName(midi);
        const dur = n.durBeats;
        const evt = { time: t, note: noteName, durBeats: dur };
        t += dur;
        return evt;
      });

      part = new Tone.Part((time, value) => {
        // MonoSynth expects triggerAttackRelease too; PolySynth supports it as well
        const durSeconds = Tone.Time(value.durBeats).toSeconds();
        instrument.triggerAttackRelease(value.note, durSeconds, time);
      }, events).start(0);

      Tone.Transport.start();
    }

    // ============================================================
    // NEW: Piano roll rendering (auto-fit so whole melody is visible)
    // ============================================================
    function sumBeats(notes){ return notes.reduce((a,n)=>a+n.durBeats, 0); }

    function computePhraseStats(notes){
      const midis = notes.map(n => n.midi);
      const lo = Math.min(...midis);
      const hi = Math.max(...midis);
      const totalBeats = sumBeats(notes);
      return { lo, hi, totalBeats };
    }

    function drawPianoRoll(notes){
      const ctx = pianoRoll.getContext("2d");
      if (!notes || !notes.length){
        // clear
        ctx.clearRect(0,0,pianoRoll.width,pianoRoll.height);
        rollInfo.textContent = "—";
        return;
      }

      const { lo, hi, totalBeats } = computePhraseStats(notes);

      // Padding in semitones so the full melody has breathing room
      const pad = 2;
      const minMidi = Math.max(24, lo - pad);
      const maxMidi = Math.min(108, hi + pad);
      const rows = Math.max(1, (maxMidi - minMidi + 1));

      // Layout
      const showLabels = labelsRoll.checked;
      const showGrid = gridRoll.checked;
      const fit = fitRoll.checked;

      // Choose cell sizes. If fit mode: compute height so ALL rows are visible (no vertical crop).
      const leftPad = showLabels ? 56 : 12;
      const rightPad = 12;
      const topPad = 12;
      const bottomPad = 12;

      // Width uses canvas width; height is dynamic if "Fit to melody" is checked.
      const w = pianoRoll.width;
      let rowH = 12; // default row height
      if (fit){
        // Cap row height so it doesn't get comically tall for small ranges; keep it readable.
        // Total height = top + bottom + rows*rowH
        rowH = clamp(Math.floor((520 - topPad - bottomPad) / rows), 8, 18);
        const targetH = topPad + bottomPad + rows * rowH;
        // Set canvas height directly; CSS keeps it responsive.
        pianoRoll.height = targetH;
      } else {
        // Fixed size; user can still see most content
        pianoRoll.height = 260;
        rowH = Math.max(8, Math.floor((pianoRoll.height - topPad - bottomPad) / rows));
      }
      const h = pianoRoll.height;

      // Background
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = "rgba(5,5,12,0.65)";
      ctx.fillRect(0,0,w,h);

      // Compute x scale
      const usableW = w - leftPad - rightPad;
      const beatW = usableW / Math.max(0.0001, totalBeats);

      // Optional grid lines (beats)
      if (showGrid){
        ctx.save();
        ctx.globalAlpha = 0.35;
        // draw beat lines at every 0.5 beat (eighths) and stronger at integers
        for (let b = 0; b <= Math.ceil(totalBeats * 2); b++){
          const beat = b * 0.5;
          const x = leftPad + beat * beatW;
          ctx.beginPath();
          ctx.strokeStyle = (b % 2 === 0) ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.10)";
          ctx.lineWidth = (b % 2 === 0) ? 1.2 : 1.0;
          ctx.moveTo(x, topPad);
          ctx.lineTo(x, h - bottomPad);
          ctx.stroke();
        }
        ctx.restore();
      }

      // Horizontal key stripes
      ctx.save();
      for (let m = minMidi; m <= maxMidi; m++){
        const pc = m % 12;
        const isBlack = [1,3,6,8,10].includes(pc);
        const y = topPad + (maxMidi - m) * rowH;
        ctx.fillStyle = isBlack ? "rgba(255,255,255,0.04)" : "rgba(255,255,255,0.02)";
        ctx.fillRect(leftPad, y, usableW, rowH);
      }
      ctx.restore();

      // Labels (note names on the left)
      if (showLabels){
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.72)";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
        // label every C line to avoid clutter
        for (let m = minMidi; m <= maxMidi; m++){
          if (m % 12 !== 0) continue; // C only
          const y = topPad + (maxMidi - m) * rowH + Math.floor(rowH * 0.78);
          ctx.fillText(midiToNoteName(m), 10, y);
        }
        ctx.restore();
      }

      // Draw notes (rectangles)
      let t = 0;
      for (let i=0; i<notes.length; i++){
        const n = notes[i];
        const x = leftPad + t * beatW;
        const nw = Math.max(2, n.durBeats * beatW);
        const y = topPad + (maxMidi - n.midi) * rowH + 1;
        const nh = Math.max(2, rowH - 2);

        // note body
        ctx.save();
        ctx.fillStyle = "rgba(120,140,255,0.35)";
        ctx.strokeStyle = "rgba(120,140,255,0.65)";
        ctx.lineWidth = 1;

        roundRect(ctx, x + 1, y, nw - 2, nh, 6);
        ctx.fill();
        ctx.globalAlpha = 0.9;
        ctx.stroke();

        // tiny note label on long notes
        if (nw > 44 && nh >= 10){
          ctx.globalAlpha = 0.85;
          ctx.fillStyle = "rgba(235,240,255,0.9)";
          ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
          ctx.fillText(midiToNoteName(n.midi), x + 8, y + Math.floor(nh * 0.72));
        }

        ctx.restore();
        t += n.durBeats;
      }

      // Border
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, w-1, h-1);
      ctx.restore();

      // Info line
      rollInfo.textContent = `Range: ${hi - lo} semitones • Notes: ${notes.length} • Total: ${totalBeats.toFixed(2)} beats • Display: ${minMidi}-${maxMidi}`;
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    // Re-render piano roll when toggles change
    fitRoll.addEventListener("change", () => drawPianoRoll(phrase));
    gridRoll.addEventListener("change", () => drawPianoRoll(phrase));
    labelsRoll.addEventListener("change", () => drawPianoRoll(phrase));

    // ============================================================
    // NEW: Melody explanation (why the phrase works)
    // ============================================================
    function describeMelody(notes, key, mode){
      if (!notes || !notes.length) return "Generate a phrase to see a short explanation of its contour + cadence.";

      const midis = notes.map(n => n.midi);
      const N = midis.length;
      const start = midis[0];
      const end = midis[N-1];
      const peak = Math.max(...midis);
      const trough = Math.min(...midis);
      const peakIdx = midis.indexOf(peak);
      const troughIdx = midis.indexOf(trough);

      // Step/leap breakdown
      let steps = 0, leaps = 0;
      for (let i=1;i<N;i++){
        const iv = Math.abs(midis[i]-midis[i-1]);
        if (iv <= 2) steps++; else leaps++;
      }
      const stepPct = Math.round(100 * steps / Math.max(1,(N-1)));

      // Cadence check: last note near tonic or dominant
      const root = NOTE_TO_SEMITONE[key];
      const tonicPc = root % 12;
      const domPc = (root + 7) % 12;
      const endPc = end % 12;
      const cadenceType = (endPc === tonicPc) ? "tonic (resolved)" : (endPc === domPc) ? "dominant (open)" : "non-triad tone (color)";

      // Contour summary
      const contour =
        (peakIdx > 0 && peakIdx < N-1) ? "arch-shaped" :
        (end > start) ? "overall rising" :
        (end < start) ? "overall falling" : "balanced";

      // Register mention
      const range = peak - trough;

      return (
        `This phrase in ${key} ${mode.replaceAll("_"," ")} tends to feel coherent because it combines ` +
        `a ${contour} contour (high point around note ${peakIdx+1}, low around note ${troughIdx+1}) ` +
        `with mostly stepwise motion (${stepPct}% steps), which makes it singable and “connected.” ` +
        `It closes by leaning toward the ${cadenceType}, giving a clear sense of ending. ` +
        `The pitch range is ${range} semitones—wide enough to feel expressive, but not so wide that it becomes jumpy.`
      );
    }

    // ============================================================
    // NEW: Copy + MIDI export (no external libs)
    // ============================================================
    function notesToText(notes){
      if (!notes) return "";
      return notes.map(n => `${midiToNoteName(n.midi)}:${n.durBeats}`).join(", ");
    }

    copyBtn.addEventListener("click", async () => {
      if (!phrase) return;
      const text = notesToText(phrase);
      try{
        await navigator.clipboard.writeText(text);
        setWarning(null);
      }catch(e){
        // fallback
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
      }
    });

    // Minimal Standard MIDI File writer (Format 0, single track)
    // Uses PPQ = 480. Converts beats -> ticks (assuming 1 beat = quarter note).
    function exportMIDI(notes, bpm){
      const PPQ = 480;

      // Variable-length quantity
      function vlq(n){
        let bytes = [n & 0x7F];
        while ((n >>= 7)){
          bytes.unshift((n & 0x7F) | 0x80);
        }
        return bytes;
      }

      function strBytes(s){
        return Array.from(s).map(ch => ch.charCodeAt(0));
      }

      function u16(n){ return [(n>>8)&255, n&255]; }
      function u32(n){ return [(n>>24)&255, (n>>16)&255, (n>>8)&255, n&255]; }

      // Header chunk
      const header = [
        ...strBytes("MThd"),
        ...u32(6),
        ...u16(0),       // format 0
        ...u16(1),       // 1 track
        ...u16(PPQ)      // division
      ];

      // Track events
      const ev = [];

      // Tempo meta event (microseconds per quarter)
      const mpqn = Math.round(60000000 / Math.max(1, bpm));
      ev.push(
        ...vlq(0),
        0xFF, 0x51, 0x03,
        (mpqn>>16)&255, (mpqn>>8)&255, mpqn&255
      );

      // Program change (Acoustic Grand Piano)
      ev.push(...vlq(0), 0xC0, 0x00);

      // Notes (channel 0)
      let deltaTicks = 0;
      for (const n of notes){
        const durTicks = Math.max(1, Math.round(n.durBeats * PPQ));
        // Note on
        ev.push(...vlq(deltaTicks), 0x90, clamp(n.midi,0,127), 100);
        // Note off after duration
        ev.push(...vlq(durTicks), 0x80, clamp(n.midi,0,127), 0);
        deltaTicks = 0;
      }

      // End of track
      ev.push(...vlq(0), 0xFF, 0x2F, 0x00);

      // Track chunk
      const track = [
        ...strBytes("MTrk"),
        ...u32(ev.length),
        ...ev
      ];

      const bytes = new Uint8Array([...header, ...track]);
      const blob = new Blob([bytes], { type: "audio/midi" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "generated_phrase.mid";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    exportMidiBtn.addEventListener("click", () => {
      if (!phrase) return;
      const bpm = Number(document.getElementById("tempo").value);
      exportMIDI(phrase, bpm);
    });

    // ============================================================
    // NEW: Listening study storage + CSV export
    // ============================================================
    const RATINGS_KEY = "liam_ai_music_ratings_v1";

    function loadRatings(){
      try{
        const raw = localStorage.getItem(RATINGS_KEY);
        return raw ? JSON.parse(raw) : [];
      }catch(e){
        return [];
      }
    }

    function saveRatings(list){
      localStorage.setItem(RATINGS_KEY, JSON.stringify(list));
    }

    function renderRatingsTable(){
      const list = loadRatings();
      if (!list.length){
        ratingsTable.innerHTML = `<tr><td colspan="3" class="tiny muted">No ratings yet.</td></tr>`;
        return;
      }
      // last 8
      const view = list.slice(-8).reverse();
      ratingsTable.innerHTML = view.map(r => `
        <tr>
          <td>${"★".repeat(r.stars)}${"☆".repeat(5-r.stars)}</td>
          <td>${r.key} ${r.mode.replaceAll("_"," ")}</td>
          <td>${r.length} notes</td>
        </tr>
      `).join("");
    }

    function setStars(n){
      currentStars = n;
      const stars = starBar.querySelectorAll(".star");
      stars.forEach(s => {
        const k = Number(s.dataset.star);
        s.classList.toggle("on", k <= n);
      });
      if (phrase){
        ratingHint.textContent = n ? `Selected ${n}/5. Click “Save Rating” to store it.` : "Click a star to rate.";
      } else {
        ratingHint.textContent = "Generate a phrase, then rate it.";
      }
      saveRatingBtn.disabled = !(phrase && currentStars > 0);
    }

    starBar.addEventListener("click", (e) => {
      const target = e.target.closest(".star");
      if (!target) return;
      const n = Number(target.dataset.star);
      setStars(n);
    });

    saveRatingBtn.addEventListener("click", () => {
      if (!phrase || !currentStars) return;

      const key = document.getElementById("key").value;
      const mode = document.getElementById("mode").value;
      const length = Number(document.getElementById("length").value);
      const bpm = Number(document.getElementById("tempo").value);
      const stepBias = Number(document.getElementById("smooth").value);

      const metrics = computeMetrics(phrase, key, mode);

      const entry = {
        ts: new Date().toISOString(),
        stars: currentStars,
        comment: (ratingComment.value || "").trim(),
        key, mode, length, bpm, stepBias,
        metrics,
        phrase: phrase.map(n => ({ midi: n.midi, durBeats: n.durBeats }))
      };

      const list = loadRatings();
      list.push(entry);
      saveRatings(list);

      ratingComment.value = "";
      setStars(0);
      renderRatingsTable();
      setWarning(null);
    });

    exportRatingsBtn.addEventListener("click", () => {
      const list = loadRatings();
      if (!list.length){
        setWarning("No ratings to export yet.");
        return;
      }

      const header = [
        "ts","stars","comment","key","mode","length","bpm","stepBias",
        "repetition","stepwise","range","tonal",
        "phrase"
      ];

      const rows = list.map(r => {
        const safe = (s) => `"${String(s ?? "").replaceAll('"','""')}"`;
        const phraseText = r.phrase.map(n => `${midiToNoteName(n.midi)}:${n.durBeats}`).join(" ");
        return [
          safe(r.ts),
          r.stars,
          safe(r.comment),
          safe(r.key),
          safe(r.mode),
          r.length,
          r.bpm,
          r.stepBias,
          r.metrics?.repetition?.toFixed?.(4) ?? "",
          r.metrics?.stepwise?.toFixed?.(4) ?? "",
          r.metrics?.range ?? "",
          r.metrics?.tonal?.toFixed?.(4) ?? "",
          safe(phraseText)
        ].join(",");
      });

      const csv = [header.join(","), ...rows].join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "ai_music_ratings.csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      setWarning(null);
    });

    clearRatingsBtn.addEventListener("click", () => {
      localStorage.removeItem(RATINGS_KEY);
      renderRatingsTable();
      setWarning(null);
    });

    // ----------------------------
    // Button handlers
    // ----------------------------
    generateBtn.addEventListener("click", async () => {
      stopPlayback();
      setWarning(null);

      const key = document.getElementById("key").value;
      const mode = document.getElementById("mode").value;
      const bpm = Number(document.getElementById("tempo").value);
      const stepBias = Number(document.getElementById("smooth").value);
      const length = Number(document.getElementById("length").value);

      const source = document.getElementById("source").value;
      const backendUrl = document.getElementById("backendUrl").value.trim();

      out.textContent = "Generating...";

      try {
        if (source === "hf") {
          if (!backendUrl){
            throw new Error("HF source selected, but the HF Space API URL is blank. Paste your endpoint (e.g., https://YOUR-SPACE.hf.space/generate).");
          }

          const data = await generateFromHF({
            backendUrl, key, mode, tempo: bpm, smooth: stepBias, length
          });

          phrase = data.notes;

          renderPhrase(phrase);

          // If backend returns metrics, show them; else compute locally
          const metrics = data.metrics || computeMetrics(phrase, key, mode);
          renderMetrics(metrics);

        } else {
          phrase = generatePhraseBrowser({ key, mode, smooth: stepBias, length });
          renderPhrase(phrase);
          renderMetrics(computeMetrics(phrase, key, mode));
        }

        // NEW: enable extra actions + draw piano roll + explanation
        playBtn.disabled = false;
        copyBtn.disabled = false;
        exportMidiBtn.disabled = false;

        drawPianoRoll(phrase);
        melodyExplain.textContent = describeMelody(phrase, key, mode);

        // Ratings UI now usable
        ratingHint.textContent = "Click a star to rate this phrase.";
        saveRatingBtn.disabled = !(currentStars > 0);
        renderRatingsTable();

      } catch (e) {
        phrase = null;
        playBtn.disabled = true;
        stopBtn.disabled = true;
        copyBtn.disabled = true;
        exportMidiBtn.disabled = true;
        out.textContent = "(generation failed)";
        drawPianoRoll(null);
        melodyExplain.textContent = "Generate a phrase to see a short explanation of its contour + cadence.";
        ratingHint.textContent = "Generate a phrase, then rate it.";
        saveRatingBtn.disabled = true;

        setWarning(e?.message || "Generation failed. Check console for details.");
        console.error(e);
      }
    });

    playBtn.addEventListener("click", async () => {
      if (!phrase) return;
      setWarning(null);

      try {
        await ensureAudio();
        stopPlayback();
        schedulePlayback(phrase);
        playBtn.disabled = true;
        stopBtn.disabled = false;
      } catch (e) {
        setWarning("Audio failed to start. Try clicking Play again (browser audio policy).");
        console.error(e);
      }
    });

    stopBtn.addEventListener("click", stopPlayback);

    // ============================================================
    // NEW: Keyboard shortcuts (fast demo mode)
    // ============================================================
    window.addEventListener("keydown", (e) => {
      // avoid interfering when typing in an input
      const tag = (document.activeElement?.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea") return;

      if (e.code === "Space"){
        e.preventDefault();
        if (stopBtn.disabled === false){
          stopPlayback();
        } else if (!playBtn.disabled){
          playBtn.click();
        }
      } else if (e.key.toLowerCase() === "g"){
        generateBtn.click();
      } else if (e.key.toLowerCase() === "c"){
        if (!copyBtn.disabled) copyBtn.click();
      } else if (e.key.toLowerCase() === "m"){
        if (!exportMidiBtn.disabled) exportMidiBtn.click();
      }
    });

    window.addEventListener("beforeunload", () => {
      try { stopPlayback(); } catch(e) {}
    });

    // initial render of ratings table
    renderRatingsTable();
    // initial draw
    drawPianoRoll(null);
  </script>
</body>
</html>






