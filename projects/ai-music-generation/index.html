<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Music Generation System | Liam Weir</title>

  <!-- Tone.js (audio playback) -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>

  <style>
    * { box-sizing: border-box; }

    body{
      margin:0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto;
      background:#0a0a12;
      color:#eef0ff;
    }

    /* REPLACEMENT TOP BAR (Back button only) */
    .top-bar{
      position:fixed;
      top:0;
      left:0;
      width:100%;
      background: rgba(10,10,25,0.85);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      justify-content:flex-start;
      padding: 1rem 1.2rem;
      z-index: 100;
    }

    .back-btn{
      display:inline-flex;
      align-items:center;
      gap: 0.45rem;
      color:#eef0ff;
      text-decoration:none;
      font-weight: 800;
      letter-spacing: 0.2px;
      padding: 0.55rem 0.95rem;
      border-radius: 14px;
      background: rgba(120,140,255,0.18);
      border: 1px solid rgba(120,140,255,0.35);
      transition: transform 0.15s ease, filter 0.15s ease;
    }

    .back-btn:hover{
      filter: brightness(1.15);
      transform: translateY(-1px);
    }

    main{
      max-width: 1100px;
      margin: 0 auto;
      padding: 96px 18px 48px; /* keeps spacing correct with fixed top bar */
    }

    h1{
      font-size: 2.4rem;
      margin: 0 0 10px;
    }
    p{ opacity:0.9; line-height:1.6; }

    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 18px;
      margin-top: 18px;
    }
    @media (max-width: 920px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 20px;
      padding: 18px;
      box-shadow: 0 30px 60px rgba(0,0,0,0.35);
    }

    .label{
      font-size: 0.9rem;
      opacity: 0.85;
      margin-bottom: 6px;
    }

    select, input[type="range"], input[type="text"], input[type="number"]{
      background: rgba(255,255,255,0.06);
      color: #eef0ff;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 10px 12px;
      outline: none;
      min-width: 170px;
    }

    input[type="number"]{
      min-width: 140px;
    }

    input[type="range"]{
      padding: 10px 0;
      min-width: 240px;
    }

    .btn{
      background: rgba(120,140,255,0.18);
      border: 1px solid rgba(120,140,255,0.35);
      color:#eef0ff;
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 700;
      letter-spacing: 0.2px;
      transition: transform 0.15s ease, filter 0.15s ease;
    }
    .btn:hover{ filter: brightness(1.15); transform: translateY(-1px); }
    .btn:disabled{ opacity:0.45; cursor:not-allowed; transform:none; }

    pre{
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 12px;
      overflow:auto;
      white-space: pre;
      margin: 10px 0 0;
      min-height: 180px;
    }

    .pill{
      display:inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      font-size: 0.85rem;
      opacity: 0.9;
      margin-right: 6px;
      margin-top: 10px;
    }

    .muted{ opacity: 0.8; }

    .metric{
      display:flex;
      justify-content:space-between;
      gap:10px;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .metric:last-child{ border-bottom:none; }

    .tiny{
      font-size: 0.85rem;
      opacity: 0.75;
    }

    .warn{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,180,120,0.25);
      background: rgba(255,180,120,0.08);
      color: #ffe9da;
      display:none;
    }

    .pianoroll-wrap{
      margin-top: 14px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      overflow: hidden;
    }

    .pianoroll-head{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03);
    }

    .pianoroll-title{
      font-weight: 800;
      letter-spacing: 0.2px;
      margin: 0;
      font-size: 0.95rem;
      opacity: 0.95;
    }

    .pianoroll-actions{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
      justify-content:flex-end;
    }

    .toggle{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      user-select:none;
      cursor:pointer;
      font-size: 0.88rem;
      opacity: 0.95;
    }

    .toggle input{ transform: translateY(1px); }

    /* Important: canvas uses DPR-scaled internal size; CSS keeps it readable and fully visible */
    canvas#pianoRoll{
      display:block;
      width: 100%;
      height: auto;
      background: rgba(5,5,12,0.65);
    }

    .pianoroll-foot{
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,0.08);
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content:space-between;
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 0.85rem;
      opacity: 0.9;
    }

    .stack{
      display:grid;
      gap: 18px;
      margin-top: 18px;
    }

    .two-col{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
    }
    @media (max-width: 920px){ .two-col{ grid-template-columns: 1fr; } }

    .list{
      margin: 10px 0 0;
      padding-left: 18px;
      opacity: 0.92;
      line-height: 1.65;
    }

    .divider{
      border:0;
      border-top:1px solid rgba(255,255,255,0.08);
      margin: 14px 0;
    }

    .chip{
      display:inline-block;
      margin: 6px 6px 0 0;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(120,140,255,0.10);
      font-size: 0.86rem;
      opacity: 0.95;
    }

    .rating-row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      margin-top: 8px;
    }

    .starbar{
      display:inline-flex;
      gap: 6px;
      align-items:center;
    }

    .star{
      width: 34px;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      cursor:pointer;
      display:grid;
      place-items:center;
      font-size: 18px;
      transition: transform 0.12s ease, filter 0.12s ease;
      user-select:none;
    }
    .star:hover{ transform: translateY(-1px); filter: brightness(1.1); }
    .star.on{
      background: rgba(120,140,255,0.22);
      border-color: rgba(120,140,255,0.45);
    }

    .mini-btn{
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 0.9rem;
    }

    table{
      width:100%;
      border-collapse: collapse;
      margin-top: 10px;
      font-size: 0.92rem;
      opacity: 0.95;
    }
    th, td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      vertical-align: top;
    }
    th{
      text-align:left;
      opacity: 0.85;
      font-weight: 800;
    }
  </style>
</head>

<body>
  <div class="top-bar">
    <a class="back-btn" href="https://liamnweir.github.io/liamweirportfolio.github.io/">
      ← Back to Home
    </a>
  </div>

  <main>
    <h1>AI Music Generation System</h1>
    <p class="muted">
      Generate short symbolic phrases with musical structure + simple perception metrics.
      This page runs on GitHub Pages (static). If you want a real ML model, this UI can call a Hugging Face Spaces backend (optional).
    </p>

    <div>
      <span class="pill">AI</span>
      <span class="pill">Music</span>
      <span class="pill">Perception</span>
      <span class="pill">Tone.js</span>
      <span class="pill">GitHub Pages</span>
    </div>

    <div class="grid">
      <section class="card">
        <h2 style="margin:0 0 10px;">Interactive Demo</h2>

        <div class="row">
          <div>
            <div class="label">Key</div>
            <select id="key">
              <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
              <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
              <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
            </select>
          </div>

          <div>
            <div class="label">Scale / Mode</div>
            <select id="mode">
              <option value="major">Major (Ionian)</option>
              <option value="natural_minor">Natural Minor (Aeolian)</option>
              <option value="harmonic_minor">Harmonic Minor</option>
              <option value="melodic_minor">Melodic Minor (Ascending)</option>
              <option value="dorian">Dorian</option>
              <option value="mixolydian">Mixolydian</option>
              <option value="lydian">Lydian</option>
              <option value="phrygian">Phrygian</option>
              <option value="locrian">Locrian</option>
            </select>
          </div>

          <div style="min-width: 260px;">
            <div class="label">Tempo: <span id="tempoVal">110</span> BPM</div>
            <input id="tempo" type="range" min="70" max="170" value="110" />
          </div>

          <div style="min-width: 280px;">
            <div class="label">Stepwise Bias: <span id="smoothVal">0.75</span></div>
            <input id="smooth" type="range" min="0" max="1" step="0.01" value="0.75" />
          </div>

          <div>
            <div class="label">Length</div>
            <select id="length">
              <option value="8">8 notes</option>
              <option value="16" selected>16 notes</option>
              <option value="24">24 notes</option>
              <option value="32">32 notes</option>
            </select>
          </div>

          <!-- NEW: rhythmic complexity controls (browser generator uses these) -->
          <div>
            <div class="label">Min Note Length (beats)</div>
            <input id="minDur" type="number" step="0.01" value="0.25" min="0.01" />
          </div>
          <div>
            <div class="label">Max Note Length (beats)</div>
            <input id="maxDur" type="number" step="0.01" value="1.50" min="0.01" />
          </div>
          <div style="min-width: 280px;">
            <div class="label">Rhythm Variety: <span id="rhythmVal">0.60</span></div>
            <input id="rhythmVar" type="range" min="0" max="1" step="0.01" value="0.60" />
          </div>
          <div>
            <div class="label">Quantize Durations</div>
            <select id="quantize">
              <option value="none" selected>None (any length)</option>
              <option value="0.25">1/4 beat</option>
              <option value="0.125">1/8 beat</option>
              <option value="0.0625">1/16 beat</option>
              <option value="0.3333333">Triplet (1/3 beat)</option>
            </select>
          </div>

          <div>
            <div class="label">Instrument</div>
            <select id="instrument">
              <option value="piano" selected>Piano</option>
              <option value="guitar">Guitar (plucked)</option>
              <option value="bass">Bass</option>
              <option value="violin">Violin</option>
              <option value="strings">Strings (pad)</option>
              <option value="synth">Synth (bright)</option>
            </select>
          </div>

          <div style="min-width: 260px;">
            <div class="label">Generation Source</div>
            <select id="source">
              <option value="browser" selected>Browser (demo generator)</option>
              <option value="hf">Hugging Face (ML backend)</option>
            </select>
          </div>

          <div style="min-width: 360px; flex: 1;">
            <div class="label">HF Space API URL (optional)</div>
            <input id="backendUrl" type="text" placeholder="https://YOUR-SPACE.hf.space/generate" />
            <div class="tiny">
              Leave blank if using the browser generator. If using HF, paste your Space endpoint here.
            </div>
          </div>

          <div class="row" style="align-items:center;">
            <button class="btn" id="generateBtn">Generate</button>
            <button class="btn" id="playBtn" disabled>Play</button>
            <button class="btn" id="stopBtn" disabled>Stop</button>
            <button class="btn" id="copyBtn" disabled>Copy Notes</button>
            <button class="btn" id="exportMidiBtn" disabled>Export MIDI</button>
          </div>
        </div>

        <div id="warnBox" class="warn"></div>

        <div class="label" style="margin-top: 12px;">Generated phrase (notes + durations)</div>
        <pre id="out">(click Generate)</pre>

        <div class="pianoroll-wrap" aria-label="Piano roll">
          <div class="pianoroll-head">
            <p class="pianoroll-title">Piano Roll (fully fits the melody)</p>
            <div class="pianoroll-actions">
              <label class="toggle" title="Auto-fit height to show every pitch used (plus padding).">
                <input id="fitRoll" type="checkbox" checked />
                Fit to melody
              </label>
              <label class="toggle" title="Shows a beat grid behind notes.">
                <input id="gridRoll" type="checkbox" checked />
                Grid
              </label>
              <label class="toggle" title="Shows note names on the left.">
                <input id="labelsRoll" type="checkbox" checked />
                Labels
              </label>
            </div>
          </div>
          <canvas id="pianoRoll"></canvas>
          <div class="pianoroll-foot">
            <div class="tiny muted">
              Shortcuts: <span class="kbd">Space</span> play/stop • <span class="kbd">G</span> generate • <span class="kbd">C</span> copy • <span class="kbd">M</span> export MIDI
            </div>
            <div class="tiny muted" id="rollInfo">—</div>
          </div>
        </div>

        <p class="tiny muted" style="margin-top: 10px;">
          Tip: “Harmonic/Melodic minor” modes are great for showing musical structure in your writeup.
          If you switch the source to “Hugging Face,” the page will call your backend and keep the same UI.
        </p>
      </section>

      <aside class="card">
        <h2 style="margin:0 0 10px;">Perception / Structure Metrics</h2>
        <p class="muted" style="margin-top:0;">
          Simple heuristics you can report now, then validate with listening tests later.
        </p>

        <div class="metric"><span>Repetition Score</span><strong id="repScore">—</strong></div>
        <div class="metric"><span>Stepwise Motion</span><strong id="stepScore">—</strong></div>
        <div class="metric"><span>Range (semitones)</span><strong id="rangeScore">—</strong></div>
        <div class="metric"><span>Tonal Stability</span><strong id="tonalScore">—</strong></div>

        <!-- CRUCIAL: explanation section (auto-updated every generation) -->
        <hr style="border:0; border-top:1px solid rgba(255,255,255,0.08); margin:14px 0;" />
        <h3 style="margin:0 0 8px;">Why this melody works (in words)</h3>
        <p class="muted" style="margin-top:0;" id="melodyExplain">
          Generate a phrase to see a concrete explanation of why the produced melody tends to sound coherent.
        </p>

        <hr style="border:0; border-top:1px solid rgba(255,255,255,0.08); margin:14px 0;" />

        <h3 style="margin:0 0 8px;">What to write about</h3>
        <p class="muted" style="margin-top:0;">
          • Dataset (MIDI phrases)<br/>
          • Model (Transformer/VAE) or rule-based baseline<br/>
          • Constraints (key/mode, contour, cadence, rhythm range)<br/>
          • Evaluation (listener ratings + metrics)<br/>
          • Demo (this page) + backend endpoint
        </p>
      </aside>
    </div>

    <div class="stack">
      <section class="card">
        <h2 style="margin:0 0 6px;">Listening Study (User Ratings)</h2>
        <p class="muted" style="margin-top:0;">
          This adds a lightweight, on-page evaluation loop: listeners rate the generated phrase, and the page stores ratings locally (in your browser) so you can export a CSV later.
        </p>

        <div class="two-col">
          <div>
            <div class="label">Rate this phrase</div>
            <div class="rating-row">
              <div class="starbar" id="starBar" aria-label="Star rating">
                <div class="star" data-star="1">★</div>
                <div class="star" data-star="2">★</div>
                <div class="star" data-star="3">★</div>
                <div class="star" data-star="4">★</div>
                <div class="star" data-star="5">★</div>
              </div>
              <span class="tiny muted" id="ratingHint">Generate a phrase, then rate it.</span>
            </div>

            <div class="label" style="margin-top:10px;">Optional comment</div>
            <input id="ratingComment" type="text" placeholder="e.g., 'Nice cadence but too repetitive'" style="width:100%; min-width: unset;" />

            <div class="row" style="margin-top:12px;">
              <button class="btn mini-btn" id="saveRatingBtn" disabled>Save Rating</button>
              <button class="btn mini-btn" id="exportRatingsBtn">Export Ratings (CSV)</button>
              <button class="btn mini-btn" id="clearRatingsBtn">Clear Local Ratings</button>
            </div>
            <div class="tiny muted" style="margin-top:10px;">
              Stored locally via <span class="kbd">localStorage</span> (no server needed). If you later add a backend, you can POST these ratings to your database.
            </div>
          </div>

          <div>
            <div class="label">Saved ratings (this device)</div>
            <table>
              <thead>
                <tr>
                  <th style="width: 110px;">Stars</th>
                  <th>Key/Mode</th>
                  <th style="width: 140px;">Length</th>
                </tr>
              </thead>
              <tbody id="ratingsTable">
                <tr><td colspan="3" class="tiny muted">No ratings yet.</td></tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>

      <section class="card">
        <h2 style="margin:0 0 6px;">Paper-Style Writeup (drop-in)</h2>
        <p class="muted" style="margin-top:0;">
          This is a ready-to-paste “mini paper” outline that matches what your demo does (baseline generator + metrics + rhythm controls + listening study).
        </p>

        <hr class="divider"/>

        <h3 style="margin:0;">Abstract</h3>
        <p class="muted">
          We present a browser-based system for generating short symbolic melodies under musical constraints (key/mode, contour bias, cadence bias, and user-controlled rhythmic variability).
          We evaluate phrases with simple structure metrics and collect listener ratings through an embedded survey interface. The system supports a local rule-based baseline and optional integration with a machine-learning backend via a Hugging Face Space endpoint.
        </p>

        <div class="two-col">
          <div>
            <h3 style="margin:0;">Method</h3>
            <ul class="list">
              <li><strong>Pitch generator:</strong> stepwise-biased walk constrained to a mode; soft arch-shaped contour; cadence pull at phrase end.</li>
              <li><strong>Rhythm generator:</strong> durations sampled within user-set min/max bounds, with a variety knob and optional quantization grid.</li>
              <li><strong>Playback:</strong> Tone.js synth approximations (no samples required).</li>
            </ul>
          </div>
          <div>
            <h3 style="margin:0;">Evaluation</h3>
            <ul class="list">
              <li><strong>Objective metrics:</strong> repetition, stepwise motion, range, tonal stability.</li>
              <li><strong>Subjective:</strong> 1–5 star rating + optional comment stored locally (exportable CSV).</li>
              <li><strong>Future:</strong> compare baseline vs. Transformer via AB tests.</li>
            </ul>
          </div>
        </div>

        <hr class="divider"/>

        <h3 style="margin:0;">Results & Discussion</h3>
        <p class="muted" style="margin-top:8px;">
          The contour + cadence biases increase perceived “phrase-ness” (beginning–middle–end). Stepwise bias increases singability and reduces large leaps;
          rhythmic variability allows more complex phrasing (long notes act as anchors, shorter notes provide motion). In future work, listener ratings can be analyzed against these metrics and rhythm statistics.
        </p>

        <div style="margin-top:10px;">
          <span class="chip">Baseline vs ML comparison</span>
          <span class="chip">AB listening tests</span>
          <span class="chip">Metric–rating correlation</span>
          <span class="chip">Exportable ratings dataset</span>
        </div>
      </section>
    </div>
  </main>

  <script>
    // ----------------------------
    // Music theory helpers
    // ----------------------------
    const NOTE_TO_SEMITONE = {
      "C":0,"C#":1,"D":2,"D#":3,"E":4,"F":5,"F#":6,"G":7,"G#":8,"A":9,"A#":10,"B":11
    };

    const MODES = {
      major:         [0,2,4,5,7,9,11],
      natural_minor: [0,2,3,5,7,8,10],
      harmonic_minor:[0,2,3,5,7,8,11],
      melodic_minor: [0,2,3,5,7,9,11],
      dorian:        [0,2,3,5,7,9,10],
      mixolydian:    [0,2,4,5,7,9,10],
      lydian:        [0,2,4,6,7,9,11],
      phrygian:      [0,1,3,5,7,8,10],
      locrian:       [0,1,3,5,6,8,10]
    };

    function pick(arr){ return arr[Math.floor(Math.random() * arr.length)]; }

    function midiToNoteName(m){
      const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
      const name = names[m % 12];
      const oct = Math.floor(m / 12) - 1;
      return `${name}${oct}`;
    }

    function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

    // ----------------------------
    // UI elements
    // ----------------------------
    const tempo = document.getElementById("tempo");
    const tempoVal = document.getElementById("tempoVal");
    const smooth = document.getElementById("smooth");
    const smoothVal = document.getElementById("smoothVal");
    const generateBtn = document.getElementById("generateBtn");
    const playBtn = document.getElementById("playBtn");
    const stopBtn = document.getElementById("stopBtn");
    const out = document.getElementById("out");

    const repScoreEl = document.getElementById("repScore");
    const stepScoreEl = document.getElementById("stepScore");
    const rangeScoreEl = document.getElementById("rangeScore");
    const tonalScoreEl = document.getElementById("tonalScore");

    const warnBox = document.getElementById("warnBox");

    const copyBtn = document.getElementById("copyBtn");
    const exportMidiBtn = document.getElementById("exportMidiBtn");

    const pianoRoll = document.getElementById("pianoRoll");
    const rollInfo = document.getElementById("rollInfo");
    const fitRoll = document.getElementById("fitRoll");
    const gridRoll = document.getElementById("gridRoll");
    const labelsRoll = document.getElementById("labelsRoll");

    const melodyExplain = document.getElementById("melodyExplain");

    const minDurEl = document.getElementById("minDur");
    const maxDurEl = document.getElementById("maxDur");
    const rhythmVarEl = document.getElementById("rhythmVar");
    const rhythmVal = document.getElementById("rhythmVal");
    const quantizeEl = document.getElementById("quantize");

    const starBar = document.getElementById("starBar");
    const ratingHint = document.getElementById("ratingHint");
    const ratingComment = document.getElementById("ratingComment");
    const saveRatingBtn = document.getElementById("saveRatingBtn");
    const exportRatingsBtn = document.getElementById("exportRatingsBtn");
    const clearRatingsBtn = document.getElementById("clearRatingsBtn");
    const ratingsTable = document.getElementById("ratingsTable");

    tempo.addEventListener("input", () => tempoVal.textContent = tempo.value);
    smooth.addEventListener("input", () => smoothVal.textContent = Number(smooth.value).toFixed(2));
    rhythmVarEl.addEventListener("input", () => rhythmVal.textContent = Number(rhythmVarEl.value).toFixed(2));

    // ----------------------------
    // State
    // ----------------------------
    let phrase = null;      // [{midi, durBeats}, ...]
    let instrument = null;
    let part = null;

    let currentStars = 0;

    // ----------------------------
    // Instrument factory
    // ----------------------------
    function makeInstrument(kind){
      if (instrument) {
        try { instrument.dispose(); } catch(e) {}
        instrument = null;
      }

      const reverb = new Tone.Reverb({ decay: 2.2, wet: 0.15 }).toDestination();

      if (kind === "piano"){
        instrument = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: "triangle" },
          envelope: { attack: 0.005, decay: 0.25, sustain: 0.15, release: 0.9 }
        }).connect(reverb);

      } else if (kind === "guitar"){
        instrument = new Tone.PolySynth(Tone.PluckSynth, { volume: -6 }).connect(reverb);

      } else if (kind === "bass"){
        instrument = new Tone.MonoSynth({
          oscillator: { type: "sine" },
          filter: { Q: 2, type: "lowpass", rolloff: -24 },
          envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.4 },
          filterEnvelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.2, baseFrequency: 80, octaves: 2.2 }
        }).connect(reverb);

      } else if (kind === "violin"){
        const vib = new Tone.Vibrato(5, 0.18).connect(reverb);
        instrument = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: "sawtooth" },
          envelope: { attack: 0.06, decay: 0.15, sustain: 0.65, release: 0.6 }
        }).connect(vib);

      } else if (kind === "strings"){
        const chorus = new Tone.Chorus(2.5, 1.6, 0.25).start().connect(reverb);
        instrument = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: "sawtooth" },
          envelope: { attack: 0.2, decay: 0.2, sustain: 0.75, release: 1.4 }
        }).connect(chorus);

      } else {
        const delay = new Tone.FeedbackDelay("8n", 0.25).connect(reverb);
        instrument = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: "square" },
          envelope: { attack: 0.01, decay: 0.12, sustain: 0.2, release: 0.25 }
        }).connect(delay);
      }

      return instrument;
    }

    // ----------------------------
    // Browser generator (baseline) + NEW rhythm complexity
    // ----------------------------
    function buildAllowedNotes(rootSemitone, modeKey){
      const scale = MODES[modeKey].map(x => x + rootSemitone);
      const baseOctave = 60; // C4
      const allowed = [];
      for (let oct = -1; oct <= 1; oct++){
        for (const s of scale){
          allowed.push(baseOctave + s + 12*oct);
        }
      }
      return allowed.sort((a,b)=>a-b);
    }

    function quantizeBeats(x, q){
      if (!q || !isFinite(q) || q <= 0) return x;
      return Math.max(q, Math.round(x / q) * q);
    }

    // NEW: produces ANY duration in [minDur,maxDur], with a "variety" control and optional quantization
    function sampleDuration(minDur, maxDur, variety, quantizeStep){
      let lo = Math.max(0.01, Number(minDur) || 0.25);
      let hi = Math.max(lo, Number(maxDur) || 1.50);
      const v = clamp(Number(variety) || 0, 0, 1);

      // v=0 => near-constant (centered)
      // v=1 => full spread across the interval
      const center = (lo + hi) / 2;
      const spread = (hi - lo) / 2;

      // Mix of centered and uniform
      const r1 = (Math.random() * 2 - 1) * spread;             // uniform around center
      const r2 = (Math.random() + Math.random() - 1) * spread; // triangular around center
      const mix = (1 - v) * r2 + v * r1;

      let dur = clamp(center + mix, lo, hi);

      // Optional quantization (or none)
      if (quantizeStep !== "none"){
        const q = Number(quantizeStep);
        if (isFinite(q) && q > 0) dur = quantizeBeats(dur, q);
      }

      // Avoid exact 0
      dur = Math.max(0.01, dur);
      return dur;
    }

    function generatePhraseBrowser({ key, mode, smooth, length, minDur, maxDur, rhythmVar, quantizeStep }){
      const root = NOTE_TO_SEMITONE[key];
      const allowed = buildAllowedNotes(root, mode);

      const tonicMidi = 60 + root;
      let current = tonicMidi;

      const notes = [];
      const N = length;
      const mid = Math.floor(N / 2);

      for (let i = 0; i < N; i++){
        const neighbors = allowed.filter(n => Math.abs(n - current) <= 2);
        const broader = allowed;

        let pool = (Math.random() < smooth && neighbors.length) ? neighbors : broader;

        const target = (i <= mid) ? current + 2 : current - 2;
        pool = pool
          .map(n => ({ n, w: 1 / (1 + Math.abs(n - target)) }))
          .sort((a,b)=>b.w - a.w)
          .slice(0, Math.max(6, Math.floor(pool.length * 0.35)))
          .map(x => x.n);

        if (i >= N - 2){
          const domMidi = tonicMidi + 7;
          const nearCadence = allowed.filter(n => Math.min(Math.abs(n - tonicMidi), Math.abs(n - domMidi)) <= 3);
          if (nearCadence.length) pool = nearCadence;
        }

        current = pick(pool);

        // NEW: variable duration
        let durBeats = sampleDuration(minDur, maxDur, rhythmVar, quantizeStep);

        // Keep the very last note slightly longer (still within maxDur)
        if (i === N - 1){
          const hi = Math.max(Number(minDur)||0.01, Number(maxDur)||1.5);
          durBeats = clamp(Math.max(durBeats, Math.min(hi, (Number(minDur)||0.25) * 1.5)), 0.01, hi);
          if (quantizeStep !== "none"){
            const q = Number(quantizeStep);
            if (isFinite(q) && q > 0) durBeats = quantizeBeats(durBeats, q);
          }
        }

        notes.push({ midi: current, durBeats });
      }

      return notes;
    }

    // ----------------------------
    // Metrics
    // ----------------------------
    function computeMetrics(notes, key, mode){
      const midis = notes.map(n => n.midi);
      const unique = new Set(midis);
      const repetition = 1 - (unique.size / midis.length);

      let stepCount = 0;
      for (let i=1; i<midis.length; i++){
        const interval = Math.abs(midis[i] - midis[i-1]);
        if (interval <= 2) stepCount++;
      }
      const stepwise = stepCount / Math.max(1, (midis.length - 1));

      const range = Math.max(...midis) - Math.min(...midis);

      const root = NOTE_TO_SEMITONE[key];
      const isMinorish = (mode.includes("minor") || mode === "dorian" || mode === "phrygian" || mode === "locrian");
      const triad = isMinorish ? [0, 3, 7] : [0, 4, 7];
      const triadPC = new Set(triad.map(x => (x + root) % 12));
      const tonal = midis.filter(m => triadPC.has(m % 12)).length / midis.length;

      return { repetition, stepwise, range, tonal };
    }

    function renderPhrase(notes){
      const lines = notes.map((n, i) =>
        `${String(i+1).padStart(2,"0")}. ${midiToNoteName(n.midi)}  (${Number(n.durBeats).toFixed(3)} beats)`
      );
      out.textContent = lines.join("\n");
    }

    function renderMetrics(metrics){
      repScoreEl.textContent = metrics.repetition.toFixed(2);
      stepScoreEl.textContent = metrics.stepwise.toFixed(2);
      rangeScoreEl.textContent = String(metrics.range);
      tonalScoreEl.textContent = metrics.tonal.toFixed(2);
    }

    function setWarning(msg){
      if (!msg){
        warnBox.style.display = "none";
        warnBox.textContent = "";
        return;
      }
      warnBox.style.display = "block";
      warnBox.textContent = msg;
    }

    // ----------------------------
    // Hugging Face backend call
    // ----------------------------
    async function generateFromHF({ backendUrl, key, mode, tempo, smooth, length }){
      const res = await fetch(backendUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ key, mode, tempo, smooth, length })
      });

      if (!res.ok){
        const text = await res.text().catch(()=> "");
        throw new Error(`HF backend error (${res.status}). ${text}`.trim());
      }
      const data = await res.json();
      if (!data || !Array.isArray(data.notes)) throw new Error("HF backend response missing `notes` array.");
      return data;
    }

    // ----------------------------
    // Playback
    // ----------------------------
    async function ensureAudio(){
      if (Tone.context.state !== "running") await Tone.start();
      const kind = document.getElementById("instrument").value;
      makeInstrument(kind);
    }

    function stopPlayback(){
      if (part){
        part.stop();
        part.dispose();
        part = null;
      }
      Tone.Transport.stop();
      Tone.Transport.cancel();
      playBtn.disabled = !phrase;
      stopBtn.disabled = true;
    }

    function schedulePlayback(notes){
      const instKind = document.getElementById("instrument").value;
      const transpose = (instKind === "bass") ? -12 : 0;

      Tone.Transport.bpm.value = Number(document.getElementById("tempo").value);

      let t = 0;
      const events = notes.map(n => {
        const midi = clamp(n.midi + transpose, 24, 108);
        const noteName = midiToNoteName(midi);
        const dur = n.durBeats;
        const evt = { time: t, note: noteName, durBeats: dur };
        t += dur;
        return evt;
      });

      part = new Tone.Part((time, value) => {
        const durSeconds = Tone.Time(value.durBeats).toSeconds();
        instrument.triggerAttackRelease(value.note, durSeconds, time);
      }, events).start(0);

      Tone.Transport.start();
    }

    // ============================================================
    // Piano roll: FIXED to always fit melody (accurate pitch + duration)
    // - DPR-scaled canvas so it matches visual size (no stretching blur)
    // - Always fits the entire melody horizontally (compressed to width)
    // - Fit-to-melody ensures every pitch row is visible
    // ============================================================
    function sumBeats(notes){ return notes.reduce((a,n)=>a+n.durBeats, 0); }

    function computePhraseStats(notes){
      const midis = notes.map(n => n.midi);
      const lo = Math.min(...midis);
      const hi = Math.max(...midis);
      const totalBeats = sumBeats(notes);
      return { lo, hi, totalBeats };
    }

    function setupCanvasToContainer(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const cssW = Math.max(320, Math.floor(rect.width));
      return { dpr, cssW };
    }

    function drawPianoRoll(notes){
      const ctx = pianoRoll.getContext("2d");
      if (!notes || !notes.length){
        ctx.clearRect(0,0,pianoRoll.width,pianoRoll.height);
        rollInfo.textContent = "—";
        return;
      }

      const { lo, hi, totalBeats } = computePhraseStats(notes);

      const pad = 2;
      const minMidi = Math.max(24, lo - pad);
      const maxMidi = Math.min(108, hi + pad);
      const rows = Math.max(1, (maxMidi - minMidi + 1));

      const showLabels = labelsRoll.checked;
      const showGrid = gridRoll.checked;
      const fit = fitRoll.checked;

      const leftPad = showLabels ? 64 : 12;
      const rightPad = 12;
      const topPad = 12;
      const bottomPad = 12;

      // Canvas width must match container width (DPR-scaled) for accuracy
      const { dpr, cssW } = setupCanvasToContainer(pianoRoll);

      // Choose row height so all pitches are visible (fit mode)
      let rowH;
      if (fit){
        // Aim for readable rows but guarantee full visibility
        rowH = clamp(Math.floor(520 / rows), 9, 18);
      } else {
        rowH = clamp(Math.floor(260 / rows), 8, 14);
      }

      const cssH = topPad + bottomPad + rows * rowH;

      // Set internal resolution (DPR) + CSS size
      pianoRoll.style.width = "100%";
      pianoRoll.style.height = "auto";
      pianoRoll.width = Math.floor(cssW * dpr);
      pianoRoll.height = Math.floor(cssH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels

      const w = cssW;
      const h = cssH;

      // Background
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = "rgba(5,5,12,0.85)";
      ctx.fillRect(0,0,w,h);

      const usableW = Math.max(1, w - leftPad - rightPad);
      const beatW = usableW / Math.max(0.0001, totalBeats); // compress to fit: whole melody always visible

      // Grid step adapts to total length (makes it easier to follow)
      // shorter phrases: finer grid; longer phrases: coarser
      let gridStep = 0.25; // quarter beat
      if (totalBeats > 16) gridStep = 1;
      if (totalBeats > 32) gridStep = 2;
      if (totalBeats > 64) gridStep = 4;

      if (showGrid){
        ctx.save();
        for (let b = 0; b <= Math.ceil(totalBeats / gridStep); b++){
          const beat = b * gridStep;
          const x = leftPad + beat * beatW;
          ctx.beginPath();
          const strong = (b % 4 === 0);
          ctx.strokeStyle = strong ? "rgba(255,255,255,0.22)" : "rgba(255,255,255,0.10)";
          ctx.lineWidth = strong ? 1.25 : 1.0;
          ctx.moveTo(x, topPad);
          ctx.lineTo(x, h - bottomPad);
          ctx.stroke();
        }
        ctx.restore();
      }

      // Key stripes
      ctx.save();
      for (let m = minMidi; m <= maxMidi; m++){
        const pc = m % 12;
        const isBlack = [1,3,6,8,10].includes(pc);
        const y = topPad + (maxMidi - m) * rowH;
        ctx.fillStyle = isBlack ? "rgba(255,255,255,0.045)" : "rgba(255,255,255,0.025)";
        ctx.fillRect(leftPad, y, usableW, rowH);
      }
      ctx.restore();

      // Labels
      if (showLabels){
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.72)";
        ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
        for (let m = minMidi; m <= maxMidi; m++){
          // label C and G to help tracking without clutter
          const pc = m % 12;
          if (pc !== 0 && pc !== 7) continue;
          const y = topPad + (maxMidi - m) * rowH + Math.floor(rowH * 0.78);
          ctx.fillText(midiToNoteName(m), 10, y);
        }
        ctx.restore();
      }

      // Notes (exact durations + order)
      let t = 0;
      for (let i=0; i<notes.length; i++){
        const n = notes[i];
        const x = leftPad + t * beatW;
        const nw = Math.max(2, n.durBeats * beatW);
        const y = topPad + (maxMidi - n.midi) * rowH + 1;
        const nh = Math.max(2, rowH - 2);

        ctx.save();
        ctx.fillStyle = "rgba(120,140,255,0.40)";
        ctx.strokeStyle = "rgba(120,140,255,0.75)";
        ctx.lineWidth = 1;

        roundRect(ctx, x + 1, y, Math.max(2, nw - 2), nh, 6);
        ctx.fill();
        ctx.globalAlpha = 0.95;
        ctx.stroke();

        // show note label if it helps (long notes)
        if (nw > 52 && nh >= 11){
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = "rgba(235,240,255,0.92)";
          ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
          ctx.fillText(midiToNoteName(n.midi), x + 8, y + Math.floor(nh * 0.72));
        }

        ctx.restore();
        t += n.durBeats;
      }

      // Border
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, w-1, h-1);
      ctx.restore();

      rollInfo.textContent =
        `Range: ${hi - lo} semitones • Notes: ${notes.length} • Total: ${totalBeats.toFixed(2)} beats • Fit: ${minMidi}-${maxMidi}`;
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    fitRoll.addEventListener("change", () => drawPianoRoll(phrase));
    gridRoll.addEventListener("change", () => drawPianoRoll(phrase));
    labelsRoll.addEventListener("change", () => drawPianoRoll(phrase));
    window.addEventListener("resize", () => drawPianoRoll(phrase));

    // ============================================================
    // CRUCIAL: Explanation section (specific, per generated melody)
    // ============================================================
    function describeMelody(notes, key, mode){
      if (!notes || !notes.length) return "Generate a phrase to see a concrete explanation of why the produced melody tends to sound coherent.";

      const midis = notes.map(n => n.midi);
      const durs = notes.map(n => n.durBeats);
      const N = midis.length;

      const start = midis[0];
      const end = midis[N-1];
      const peak = Math.max(...midis);
      const trough = Math.min(...midis);
      const peakIdx = midis.indexOf(peak);
      const troughIdx = midis.indexOf(trough);

      let steps = 0, leaps = 0;
      for (let i=1;i<N;i++){
        const iv = Math.abs(midis[i]-midis[i-1]);
        if (iv <= 2) steps++; else leaps++;
      }
      const stepPct = Math.round(100 * steps / Math.max(1,(N-1)));

      const root = NOTE_TO_SEMITONE[key];
      const tonicPc = root % 12;
      const domPc = (root + 7) % 12;
      const endPc = end % 12;
      const cadenceType =
        (endPc === tonicPc) ? "tonic resolution (strong closure)" :
        (endPc === domPc) ? "dominant landing (open / wants continuation)" :
        "a non-triad tone (color tone closure)";

      const contour =
        (peakIdx > 0 && peakIdx < N-1) ? "arch-shaped (rise then fall)" :
        (end > start) ? "overall rising" :
        (end < start) ? "overall falling" : "balanced";

      const range = peak - trough;

      const total = durs.reduce((a,b)=>a+b,0);
      const minD = Math.min(...durs);
      const maxD = Math.max(...durs);
      const longNotes = durs.filter(x => x >= (minD + (maxD-minD)*0.66)).length;

      return (
        `This phrase in ${key} ${mode.replaceAll("_"," ")} tends to work musically because it has ` +
        `${contour} contour (high point near note ${peakIdx+1}, low near note ${troughIdx+1}), ` +
        `and it keeps motion mostly stepwise (${stepPct}% steps), which makes the line feel connected and singable. ` +
        `The ending leans toward ${cadenceType}, which helps your ear interpret it as a “phrase” with an endpoint. ` +
        `Its pitch range is ${range} semitones (expressive without feeling random). ` +
        `Rhythm-wise, the phrase spans ${total.toFixed(2)} beats with durations from ${minD.toFixed(3)} to ${maxD.toFixed(3)} beats; ` +
        `${longNotes ? "a few longer notes act as anchors while shorter notes provide motion." : "durations stay relatively even, which keeps the groove steady."}`
      );
    }

    // ============================================================
    // Copy + MIDI export
    // ============================================================
    function notesToText(notes){
      if (!notes) return "";
      return notes.map(n => `${midiToNoteName(n.midi)}:${Number(n.durBeats).toFixed(3)}`).join(", ");
    }

    copyBtn.addEventListener("click", async () => {
      if (!phrase) return;
      const text = notesToText(phrase);
      try{
        await navigator.clipboard.writeText(text);
        setWarning(null);
      }catch(e){
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        document.body.removeChild(ta);
      }
    });

    function exportMIDI(notes, bpm){
      const PPQ = 480;

      function vlq(n){
        let bytes = [n & 0x7F];
        while ((n >>= 7)){
          bytes.unshift((n & 0x7F) | 0x80);
        }
        return bytes;
      }

      function strBytes(s){ return Array.from(s).map(ch => ch.charCodeAt(0)); }
      function u16(n){ return [(n>>8)&255, n&255]; }
      function u32(n){ return [(n>>24)&255, (n>>16)&255, (n>>8)&255, n&255]; }

      const header = [
        ...strBytes("MThd"),
        ...u32(6),
        ...u16(0),
        ...u16(1),
        ...u16(PPQ)
      ];

      const ev = [];
      const mpqn = Math.round(60000000 / Math.max(1, bpm));
      ev.push(...vlq(0), 0xFF, 0x51, 0x03, (mpqn>>16)&255, (mpqn>>8)&255, mpqn&255);
      ev.push(...vlq(0), 0xC0, 0x00);

      let deltaTicks = 0;
      for (const n of notes){
        const durTicks = Math.max(1, Math.round(n.durBeats * PPQ));
        ev.push(...vlq(deltaTicks), 0x90, clamp(n.midi,0,127), 100);
        ev.push(...vlq(durTicks), 0x80, clamp(n.midi,0,127), 0);
        deltaTicks = 0;
      }

      ev.push(...vlq(0), 0xFF, 0x2F, 0x00);

      const track = [
        ...strBytes("MTrk"),
        ...u32(ev.length),
        ...ev
      ];

      const bytes = new Uint8Array([...header, ...track]);
      const blob = new Blob([bytes], { type: "audio/midi" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "generated_phrase.mid";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    exportMidiBtn.addEventListener("click", () => {
      if (!phrase) return;
      const bpm = Number(document.getElementById("tempo").value);
      exportMIDI(phrase, bpm);
    });

    // ============================================================
    // Listening study storage + CSV export
    // ============================================================
    const RATINGS_KEY = "liam_ai_music_ratings_v1";

    function loadRatings(){
      try{
        const raw = localStorage.getItem(RATINGS_KEY);
        return raw ? JSON.parse(raw) : [];
      }catch(e){
        return [];
      }
    }

    function saveRatings(list){
      localStorage.setItem(RATINGS_KEY, JSON.stringify(list));
    }

    function renderRatingsTable(){
      const list = loadRatings();
      if (!list.length){
        ratingsTable.innerHTML = `<tr><td colspan="3" class="tiny muted">No ratings yet.</td></tr>`;
        return;
      }
      const view = list.slice(-8).reverse();
      ratingsTable.innerHTML = view.map(r => `
        <tr>
          <td>${"★".repeat(r.stars)}${"☆".repeat(5-r.stars)}</td>
          <td>${r.key} ${r.mode.replaceAll("_"," ")}</td>
          <td>${r.length} notes</td>
        </tr>
      `).join("");
    }

    function setStars(n){
      currentStars = n;
      const stars = starBar.querySelectorAll(".star");
      stars.forEach(s => {
        const k = Number(s.dataset.star);
        s.classList.toggle("on", k <= n);
      });
      if (phrase){
        ratingHint.textContent = n ? `Selected ${n}/5. Click “Save Rating” to store it.` : "Click a star to rate.";
      } else {
        ratingHint.textContent = "Generate a phrase, then rate it.";
      }
      saveRatingBtn.disabled = !(phrase && currentStars > 0);
    }

    starBar.addEventListener("click", (e) => {
      const target = e.target.closest(".star");
      if (!target) return;
      const n = Number(target.dataset.star);
      setStars(n);
    });

    saveRatingBtn.addEventListener("click", () => {
      if (!phrase || !currentStars) return;

      const key = document.getElementById("key").value;
      const mode = document.getElementById("mode").value;
      const length = Number(document.getElementById("length").value);
      const bpm = Number(document.getElementById("tempo").value);
      const stepBias = Number(document.getElementById("smooth").value);

      const metrics = computeMetrics(phrase, key, mode);

      const entry = {
        ts: new Date().toISOString(),
        stars: currentStars,
        comment: (ratingComment.value || "").trim(),
        key, mode, length, bpm, stepBias,
        minDur: Number(minDurEl.value),
        maxDur: Number(maxDurEl.value),
        rhythmVar: Number(rhythmVarEl.value),
        quantize: quantizeEl.value,
        metrics,
        phrase: phrase.map(n => ({ midi: n.midi, durBeats: n.durBeats }))
      };

      const list = loadRatings();
      list.push(entry);
      saveRatings(list);

      ratingComment.value = "";
      setStars(0);
      renderRatingsTable();
      setWarning(null);
    });

    exportRatingsBtn.addEventListener("click", () => {
      const list = loadRatings();
      if (!list.length){
        setWarning("No ratings to export yet.");
        return;
      }

      const header = [
        "ts","stars","comment","key","mode","length","bpm","stepBias",
        "minDur","maxDur","rhythmVar","quantize",
        "repetition","stepwise","range","tonal",
        "phrase"
      ];

      const rows = list.map(r => {
        const safe = (s) => `"${String(s ?? "").replaceAll('"','""')}"`;
        const phraseText = r.phrase.map(n => `${midiToNoteName(n.midi)}:${Number(n.durBeats).toFixed(3)}`).join(" ");
        return [
          safe(r.ts),
          r.stars,
          safe(r.comment),
          safe(r.key),
          safe(r.mode),
          r.length,
          r.bpm,
          r.stepBias,
          r.minDur,
          r.maxDur,
          r.rhythmVar,
          safe(r.quantize),
          r.metrics?.repetition?.toFixed?.(4) ?? "",
          r.metrics?.stepwise?.toFixed?.(4) ?? "",
          r.metrics?.range ?? "",
          r.metrics?.tonal?.toFixed?.(4) ?? "",
          safe(phraseText)
        ].join(",");
      });

      const csv = [header.join(","), ...rows].join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "ai_music_ratings.csv";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      setWarning(null);
    });

    clearRatingsBtn.addEventListener("click", () => {
      localStorage.removeItem(RATINGS_KEY);
      renderRatingsTable();
      setWarning(null);
    });

    // ----------------------------
    // Button handlers
    // ----------------------------
    generateBtn.addEventListener("click", async () => {
      stopPlayback();
      setWarning(null);

      const key = document.getElementById("key").value;
      const mode = document.getElementById("mode").value;
      const bpm = Number(document.getElementById("tempo").value);
      const stepBias = Number(document.getElementById("smooth").value);
      const length = Number(document.getElementById("length").value);

      const minDur = Number(minDurEl.value);
      const maxDur = Number(maxDurEl.value);
      const rhythmVar = Number(rhythmVarEl.value);
      const quantizeStep = quantizeEl.value;

      const source = document.getElementById("source").value;
      const backendUrl = document.getElementById("backendUrl").value.trim();

      out.textContent = "Generating...";

      try {
        if (source === "hf") {
          if (!backendUrl){
            throw new Error("HF source selected, but the HF Space API URL is blank. Paste your endpoint (e.g., https://YOUR-SPACE.hf.space/generate).");
          }

          const data = await generateFromHF({
            backendUrl, key, mode, tempo: bpm, smooth: stepBias, length
          });

          phrase = data.notes;

          renderPhrase(phrase);

          const metrics = data.metrics || computeMetrics(phrase, key, mode);
          renderMetrics(metrics);

        } else {
          // Browser generator uses rhythm controls (any duration imaginable)
          if (!isFinite(minDur) || !isFinite(maxDur) || minDur <= 0 || maxDur <= 0){
            throw new Error("Min/Max Note Length must be positive numbers.");
          }
          if (maxDur < minDur){
            throw new Error("Max Note Length must be ≥ Min Note Length.");
          }

          phrase = generatePhraseBrowser({
            key, mode,
            smooth: stepBias,
            length,
            minDur, maxDur,
            rhythmVar,
            quantizeStep
          });

          renderPhrase(phrase);
          renderMetrics(computeMetrics(phrase, key, mode));
        }

        playBtn.disabled = false;
        copyBtn.disabled = false;
        exportMidiBtn.disabled = false;

        drawPianoRoll(phrase);
        melodyExplain.textContent = describeMelody(phrase, key, mode);

        ratingHint.textContent = "Click a star to rate this phrase.";
        saveRatingBtn.disabled = !(currentStars > 0);
        renderRatingsTable();

      } catch (e) {
        phrase = null;
        playBtn.disabled = true;
        stopBtn.disabled = true;
        copyBtn.disabled = true;
        exportMidiBtn.disabled = true;
        out.textContent = "(generation failed)";
        drawPianoRoll(null);
        melodyExplain.textContent = "Generate a phrase to see a concrete explanation of why the produced melody tends to sound coherent.";
        ratingHint.textContent = "Generate a phrase, then rate it.";
        saveRatingBtn.disabled = true;

        setWarning(e?.message || "Generation failed. Check console for details.");
        console.error(e);
      }
    });

    playBtn.addEventListener("click", async () => {
      if (!phrase) return;
      setWarning(null);

      try {
        await ensureAudio();
        stopPlayback();
        schedulePlayback(phrase);
        playBtn.disabled = true;
        stopBtn.disabled = false;
      } catch (e) {
        setWarning("Audio failed to start. Try clicking Play again (browser audio policy).");
        console.error(e);
      }
    });

    stopBtn.addEventListener("click", stopPlayback);

    window.addEventListener("keydown", (e) => {
      const tag = (document.activeElement?.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea") return;

      if (e.code === "Space"){
        e.preventDefault();
        if (stopBtn.disabled === false){
          stopPlayback();
        } else if (!playBtn.disabled){
          playBtn.click();
        }
      } else if (e.key.toLowerCase() === "g"){
        generateBtn.click();
      } else if (e.key.toLowerCase() === "c"){
        if (!copyBtn.disabled) copyBtn.click();
      } else if (e.key.toLowerCase() === "m"){
        if (!exportMidiBtn.disabled) exportMidiBtn.click();
      }
    });

    window.addEventListener("beforeunload", () => {
      try { stopPlayback(); } catch(e) {}
    });

    renderRatingsTable();
    drawPianoRoll(null);
  </script>
</body>
</html>







